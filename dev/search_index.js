var documenterSearchIndex = {"docs":
[{"location":"lib/framework/scanner.html#Scanner-Construction","page":"Scanner","title":"Scanner Construction","text":"","category":"section"},{"location":"lib/framework/scanner.html#MPIMeasurements.MPIScanner","page":"Scanner","title":"MPIMeasurements.MPIScanner","text":"Basic description of a scanner.\n\nname: Name of the scanner\nconfigFile: Path to the used configuration file.\ngeneralParams: General parameters of the scanner like its bore size or gradient.\ndevices: Device instances instantiated by the scanner from its configuration.\n\n\n\n\n\n","category":"type"},{"location":"lib/framework/scanner.html#MPIMeasurements.name","page":"Scanner","title":"MPIMeasurements.name","text":"Name of the scanner\n\n\n\n\n\n","category":"function"},{"location":"lib/framework/scanner.html#MPIMeasurements.configDir","page":"Scanner","title":"MPIMeasurements.configDir","text":"Path to the used configuration directory.\n\n\n\n\n\nRetrieve the configuration directory of the scanner that the device is contructed from.\n\n\n\n\n\n","category":"function"},{"location":"lib/framework/scanner.html#MPIMeasurements.generalParams","page":"Scanner","title":"MPIMeasurements.generalParams","text":"General parameters of the scanner like its bore size or gradient.\n\n\n\n\n\n","category":"function"},{"location":"lib/framework/scanner.html#MPIMeasurements.scannerBoreSize","page":"Scanner","title":"MPIMeasurements.scannerBoreSize","text":"Bore size of the scanner.\n\n\n\n\n\n","category":"function"},{"location":"lib/framework/scanner.html#MPIMeasurements.scannerFacility","page":"Scanner","title":"MPIMeasurements.scannerFacility","text":"Facility where the scanner is located.\n\n\n\n\n\n","category":"function"},{"location":"lib/framework/scanner.html#MPIMeasurements.scannerManufacturer","page":"Scanner","title":"MPIMeasurements.scannerManufacturer","text":"Manufacturer of the scanner.\n\n\n\n\n\n","category":"function"},{"location":"lib/framework/scanner.html#MPIMeasurements.scannerName","page":"Scanner","title":"MPIMeasurements.scannerName","text":"Name of the scanner\n\n\n\n\n\n","category":"function"},{"location":"lib/framework/scanner.html#MPIMeasurements.scannerTopology","page":"Scanner","title":"MPIMeasurements.scannerTopology","text":"Topology of the scanner, e.g. FFL or FFP.\n\n\n\n\n\n","category":"function"},{"location":"lib/framework/scanner.html#MPIMeasurements.scannerGradient","page":"Scanner","title":"MPIMeasurements.scannerGradient","text":"Gradient of the scanners selection field.\n\n\n\n\n\n","category":"function"},{"location":"lib/framework/scanner.html#MPIMeasurements.scannerDatasetStore","page":"Scanner","title":"MPIMeasurements.scannerDatasetStore","text":"Path of the dataset store.\n\n\n\n\n\n","category":"function"},{"location":"lib/framework/scanner.html#MPIMeasurements.defaultProtocol","page":"Scanner","title":"MPIMeasurements.defaultProtocol","text":"Default protocol of the scanner.\n\n\n\n\n\n","category":"function"},{"location":"lib/framework/scanner.html#Device-Handling","page":"Scanner","title":"Device Handling","text":"","category":"section"},{"location":"lib/framework/scanner.html#MPIMeasurements.getDevices-Tuple{MPIScanner, Type{<:Device}}","page":"Scanner","title":"MPIMeasurements.getDevices","text":"getDevices(scanner, deviceType)\n\n\nRetrieve all devices of a specific deviceType. Returns an empty vector if none are found\n\n\n\n\n\n","category":"method"},{"location":"lib/framework/scanner.html#MPIMeasurements.getDevice-Tuple{MPIScanner, Type{<:Device}}","page":"Scanner","title":"MPIMeasurements.getDevice","text":"getDevice(scanner, deviceType)\n\n\nRetrieve a device of a specific deviceType if it can be unambiguously retrieved. Returns nothing if no such device can be found and throws an error if multiple devices fit the type.\n\n\n\n\n\n","category":"method"},{"location":"lib/framework/scanner.html#MPIMeasurements.getDeviceIDs","page":"Scanner","title":"MPIMeasurements.getDeviceIDs","text":"getDeviceIDs(scanner)\n\n\nRetrieve a list of all device IDs available for the scanner.\n\n\n\n\n\n","category":"function"},{"location":"lib/framework/scanner.html#Sequence-Handling","page":"Scanner","title":"Sequence Handling","text":"","category":"section"},{"location":"lib/framework/scanner.html#MPIMeasurements.Sequence-Tuple{MPIScanner, AbstractString}","page":"Scanner","title":"MPIMeasurements.Sequence","text":"Sequence(scanner, name)\n\n\nConstructor for a sequence of name from the configuration directory specified for the scanner.\n\n\n\n\n\n","category":"method"},{"location":"lib/framework/scanner.html#MPIMeasurements.getSequenceList","page":"Scanner","title":"MPIMeasurements.getSequenceList","text":"getSequenceList(scanner)\n\n\nRetrieve a list of all sequences available for the scanner.\n\n\n\n\n\n","category":"function"},{"location":"lib/framework/scanner.html#Protocol-Handling","page":"Scanner","title":"Protocol Handling","text":"","category":"section"},{"location":"config/upgrade.html#Upgrade-Guide","page":"Upgrade Guide","title":"Upgrade Guide","text":"","category":"section"},{"location":"config/upgrade.html","page":"Upgrade Guide","title":"Upgrade Guide","text":"This page should give you hints on what to change in your configuration files when upgrading between breaking releases of this package. This guide focusses on removed or changed parameters not on new features that have a sensible default value, for that please check the release notes.","category":"page"},{"location":"config/upgrade.html#v0.5-to-v0.6","page":"Upgrade Guide","title":"v0.5 to v0.6","text":"","category":"section"},{"location":"config/upgrade.html#Scanner-and-Devices","page":"Upgrade Guide","title":"Scanner and Devices","text":"","category":"section"},{"location":"config/upgrade.html","page":"Upgrade Guide","title":"Upgrade Guide","text":"the defaultSequence parameter in the [General] section has been removed without replacement, the sequence is defined by the protocol\nthe transferFunction parameter is no longer in the [General] section, but is now a per-channel parameter attached to each DAQRxChannelParams. Use transferFunction = \"tfFile.h5:2\" to select channel 2 out of the file containing multilpe channels\nthe feedback group is removed from the tx channels and replaced by two other parameters: feedback.channelID is replaced by feedbackChannelID in the tx channel directly and feedback.calibration is replaced by the transferFunction parameter in the corresponding receive channel. The transferFunction parameter can correctly parse a single (complex) value with units\nthe limitPeak parameter has been removed from rx channels, it is only defined for tx channels","category":"page"},{"location":"config/upgrade.html#TxDAQController","page":"Upgrade Guide","title":"TxDAQController","text":"","category":"section"},{"location":"config/upgrade.html","page":"Upgrade Guide","title":"Upgrade Guide","text":"Old parameter:  \namplitudeAccuracy  \nReplaced by:  \nabsoluteAmplitudeAccuracy, absolute control accuracy threshhold with units of magnetic field, e.g. \"50µT\"  \nrelativeAmplitudeAcccuracy, defined as the allowable deviation of the amplitude as a ratio of the desired amplitude, e.g. 0.001","category":"page"},{"location":"config/upgrade.html","page":"Upgrade Guide","title":"Upgrade Guide","text":"Old parameter:  \nfieldToVoltDeviation  \nReplaced by:  \nfieldToVoltAbsDeviation, absolute threshhold for how much the actual field amplitude is allowed to vary from the expected value in units of magnetic field, to still accept the system as safe, e.g. \"5mT\"   fieldToVoltRelDeviation, relative threshhold for allowed deviation   Values will be used as rtol and atol of isapprox","category":"page"},{"location":"config/upgrade.html","page":"Upgrade Guide","title":"Upgrade Guide","text":"Old parameter:  \ncontrolPause  \nReplaced by:  \ntimeUntilStable, time in s to wait before evaluating the feedback signals after ramping","category":"page"},{"location":"config/upgrade.html","page":"Upgrade Guide","title":"Upgrade Guide","text":"Changed parameters:  \nphaseAccuracy, is now a Unitful value, specify e.g. \"0.1°\"","category":"page"},{"location":"config/upgrade.html","page":"Upgrade Guide","title":"Upgrade Guide","text":"Removed parameters:  \ncorrectCrossCoupling, if a field has decouple = true the controller will correct the cross coupling","category":"page"},{"location":"config/upgrade.html#Calibrations","page":"Upgrade Guide","title":"Calibrations","text":"","category":"section"},{"location":"config/upgrade.html","page":"Upgrade Guide","title":"Upgrade Guide","text":"Because the feedback calibration (or transfer function) is now a complex value it is possible to include the phase shift between feedback and field into this number. This allows the field phase in the Sequence.toml to be set to the desired/nominal value (\"0.0rad\" or \"sin\" for sine excitation and \"pi/2*rad\" or \"cos\" for cosine excitation) instead of correcting for the feedback phase shift using that phase value.","category":"page"},{"location":"framework/sequences.html#Sequences","page":"Sequences","title":"Sequences","text":"","category":"section"},{"location":"framework/sequences.html","page":"Sequences","title":"Sequences","text":"A Sequence is an abstract description of magnetic fields being applied during an experiment, as well as the used acquisition parameters. It is the data acquisition (DAQ) Device responsibility to produce and acquire the necessary signals described in a Sequence.","category":"page"},{"location":"framework/sequences.html","page":"Sequences","title":"Sequences","text":"MPIMeasurements.jl contains an implementation of a DAQ based on the RedPitayaDAQServer project. This, together with the MPI data format (MDF), motivated the structure of a Sequence. However, any DAQ capable of producing the following signals could be used instead. A DAQ device needs to map the channel and components mentioned in a Sequence, into its own representation.","category":"page"},{"location":"framework/sequences.html","page":"Sequences","title":"Sequences","text":"A Sequence contains a general description of itself, acquisition parameters and a list of magnetic fields. Sequences are constructed from a Scanners configuration directory as follows:","category":"page"},{"location":"framework/sequences.html","page":"Sequences","title":"Sequences","text":"julia> sequence = Sequence(scanner, \"<sequence X name>\")","category":"page"},{"location":"framework/sequences.html#General-Settings","page":"Sequences","title":"General Settings","text":"","category":"section"},{"location":"framework/sequences.html","page":"Sequences","title":"Sequences","text":"The general section contains a description string for the sequence, as well as the target scanner name and lastly the base frequency from which the other magnetic field are derived.","category":"page"},{"location":"framework/sequences.html","page":"Sequences","title":"Sequences","text":"[General]\nname = \"<Sequence Name>\"\ndescription = \"<Sequence Description>\"\ntargetScanner = \"<ScannerName>\"\nbaseFrequency = \"125MHz\"","category":"page"},{"location":"framework/sequences.html#Acquisition-Settings","page":"Sequences","title":"Acquisition Settings","text":"","category":"section"},{"location":"framework/sequences.html","page":"Sequences","title":"Sequences","text":"The acquisition settings list which receive channels of a Scanner should be acquired during a measurement and with which sampling rate. Furthermore, it contains a description of the length of a measurement or rather how much samples should be acquired and if they should be averaged. This section is related to the acquisition parameters in an MDF file. ","category":"page"},{"location":"framework/sequences.html","page":"Sequences","title":"Sequences","text":"[Acquisition]\nchannels = [\"rx1\", \"rx2\"]\nbandwidth = \"<XX>Hz\"\nnumPeriodsPerFrame = 1\nnumFrames = 1\nnumAverages = 1","category":"page"},{"location":"framework/sequences.html#Magnetic-Fields","page":"Sequences","title":"Magnetic Fields","text":"","category":"section"},{"location":"framework/sequences.html","page":"Sequences","title":"Sequences","text":"The last section of a Sequence is the description of the desired magnetic fields. A Sequence can contain any number of magnetic fields, while each magnetic field in turn can contain any number of transmit channel (TxChannel).","category":"page"},{"location":"framework/sequences.html","page":"Sequences","title":"Sequences","text":"TxChannel can be grouped into electrical or mechanical channel. The former can be further divided into periodic and into acyclic electrical channel, while the latter can be divided into mechanical translation and mechanical rotation channel.","category":"page"},{"location":"framework/sequences.html","page":"Sequences","title":"Sequences","text":"Next to these TxChannel, a magnetic field also contains parameters if its channel should be controlled, decoupled or should feature ramping of its signals.","category":"page"},{"location":"framework/sequences.html","page":"Sequences","title":"Sequences","text":"[Fields.df] # Drive Field \ncontrol = true","category":"page"},{"location":"framework/sequences.html#Periodic-Electrical-Channel","page":"Sequences","title":"Periodic Electrical Channel","text":"","category":"section"},{"location":"framework/sequences.html","page":"Sequences","title":"Sequences","text":"A periodic electrical channel is a TxChannel, that contains any number of electrical periodic functions or components. Each component is described by a divider referencing the base frequency, as well as an amplitude, phase and waveform. These components are modeled after the drive field parameters of the MDF.","category":"page"},{"location":"framework/sequences.html","page":"Sequences","title":"Sequences","text":"[Fields.df.dfx] # X Channel\ntype = \"PeriodicElectricalChannel\"\noffset = \"0.0mT\"\n\n[Fields.df.dfx.c1] # Sine Wave\ntype = \"PeriodicElectricalComponent\"\ndivider = 4864\namplitude = [\"0.0025T\"]\nphase = [\"0.0rad\"]\nwaveform = \"sine\"","category":"page"},{"location":"framework/sequences.html","page":"Sequences","title":"Sequences","text":"By default periodic electrical channel are interpreted as drive fields and in particular count towards the length of a drive field cycle.","category":"page"},{"location":"framework/sequences.html#Acyclic-Electrical-Channel","page":"Sequences","title":"Acyclic Electrical Channel","text":"","category":"section"},{"location":"framework/sequences.html","page":"Sequences","title":"Sequences","text":"An acyclic electrical channel describes changing non-periodic electrical signals. These can be used to describe multi-patch sequences as they can provide descriptions for changing gradient and offset signals during a frame.","category":"page"},{"location":"framework/sequences.html","page":"Sequences","title":"Sequences","text":"[Fields.ff] # Focus Field\ncontrol = false\n\n[Fields.ff.patches]\ntype = \"ContinuousElectricalChannel\"\ndividerSteps = 364800\ndivider = 31008000\namplitude = \"3.8A\"\noffset = \"10.0A\"\nphase = \"3.14rad\"\nwaveform = \"triangle\"","category":"page"},{"location":"framework/sequences.html","page":"Sequences","title":"Sequences","text":"The above example shows an acylic electrical channel with a 4-Hz triangular waveform sampled uniformly at 85 points. ","category":"page"},{"location":"framework/sequences.html","page":"Sequences","title":"Sequences","text":"Instead of sampling pre-defined analytical functions, it is also possible to directly state a series of values.","category":"page"},{"location":"framework/examples.html#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"framework/examples.html#Magnetic-Particle-Spectroscopy-(MPS)","page":"Examples","title":"Magnetic Particle Spectroscopy (MPS)","text":"","category":"section"},{"location":"framework/examples.html","page":"Examples","title":"Examples","text":"The following is an example setup of an MPS system based on a RedPitaya StemLab 125-14. It has the following configuration directory:","category":"page"},{"location":"framework/examples.html","page":"Examples","title":"Examples","text":"MPS/\n├── Sequences/\n│   └── MPSSequence.toml\n├── Protocols/\n│   └── MPSProtocol.toml\n└── Scanner.toml","category":"page"},{"location":"framework/examples.html","page":"Examples","title":"Examples","text":"It features two Devices: the RedPitayaDAQ device, which is responsible for signal generation and acquisition, and a virtual Device called TxDAQController. The latter Device is responsible for checking the amplitude and phase of channels that require control and iteratively improving them until the deviation has fallen below a given threshold.","category":"page"},{"location":"framework/examples.html","page":"Examples","title":"Examples","text":"The RedPitayaDAQ features one transmit channel excitation and two receive channel rx_main and feedback_main. The transmit channel is configured with calibration values, both for itself and for the feedback channel it is associated with. All channel are mapped to the channel of the Red Pitaya hardware.","category":"page"},{"location":"framework/examples.html","page":"Examples","title":"Examples","text":"To perform an MPS experiement one can use the MPIMeasurementProtocol, which takes a background and a foreground measurement and is capable of storing both in an MDF.","category":"page"},{"location":"framework/examples.html#Scanner.toml","page":"Examples","title":"Scanner.toml","text":"","category":"section"},{"location":"framework/examples.html","page":"Examples","title":"Examples","text":"[General]\nboreSize = \"6mm\"\nfacility = \"Universitätsklinikum Hamburg-Eppendorf\"\nmanufacturer = \"IBI\"\nname = \"MPS\"\ntopology = \"MPS\"\ngradient = \"0T/m\"\n\n[Runtime]\ndatasetStore = \"/opt/data/MPS\"\ndefaultProtocol = \"MPSMeasurement\"\nproducerThreadID = 2\nconsumerThreadID = 3\nprotocolThreadID = 4\n\n[Devices]\ninitializationOrder = [\n  \"txController\",\n  \"rp_cluster\"\n]\n\n[Devices.rp_cluster]\ndeviceType = \"RedPitayaDAQ\"\ndependencies = [\"txController\"]\nips = [\"192.168.1.100\"]\nrampingMode = \"STARTUP\"\nrampingFraction = 0.2\ntriggerMode = \"INTERNAL\"\n\n[Devices.rp_cluster.excitation]\ntype = \"tx\"\nchannel = 1\nlimitPeak = \"1.0V\"\nsinkImpedance = \"HIGH\"\ncalibration = \"20.5V/T\"\nfeedback.channelID = \"feedback_main\"\nfeedback.calibration = \"0.017T/V\"\n\n[Devices.rp_cluster.rx_main]\ntype = \"rx\"\nchannel = 1\n\n[Devices.rp_cluster.feedback_main]\ntype = \"rx\"\nchannel = 2\n\n[Devices.txController]\ndeviceType = \"TxDAQController\"\ndependencies = [\"rp_cluster\"]\nphaseAccuracy = 0.1\namplitudeAccuracy = 0.01\nmaxControlSteps = 10","category":"page"},{"location":"framework/examples.html#MPSProtocol.toml","page":"Examples","title":"MPSProtocol.toml","text":"","category":"section"},{"location":"framework/examples.html","page":"Examples","title":"Examples","text":"type = \"MPIMeasurementProtocol\"\ndescription = \"Default measurement protocol for the MPS scanner. Acquires a background and forground measurement\"\ntargetScanner = \"MPS\"\n\nsequence = \"MPSSequence\"\ncontrolTx = true\nfgFrames = 10\nbgFrames = 10","category":"page"},{"location":"framework/examples.html#MPSSequence.toml","page":"Examples","title":"MPSSequence.toml","text":"","category":"section"},{"location":"framework/examples.html","page":"Examples","title":"Examples","text":"[General]\nname = \"MPSSequence\"\ndescription = \"A sequence with a 26.042 kHz excitation frequency.\"\ntargetScanner = \"MPS\"\nbaseFrequency = \"125.0MHz\"\n\n[Fields]\n\n[Fields.ex]\nsafeStartInterval = \"0.1s\"\nsafeEndInterval = \"0.1s\"\nsafeErrorInterval = \"0.1s\"\ncontrol = true\ndecouple = false\n\n[Fields.ex.excitation]\noffset = \"0.0mT\"\n\n[Fields.ex.excitation.c1]\ndivider = 4800\namplitude = [\"20mT\"]\nphase = [\"0.0rad\"]\nwaveform = \"sine\"\n\n[Acquisition]\nchannels = [\"rx_main\"]\nbandwidth = \"3.90625MHz\"\nnumPeriodsPerFrame = 1\nnumFrames = 1\nnumAverages = 1000\nnumFrameAverages = 1","category":"page"},{"location":"installation.html#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation.html","page":"Installation","title":"Installation","text":"The realization of a new MPI system with MPIMeasurements.jl requires the installation and preparation of three components. The first component is the Julia framework itself, the second is a set of configuration files associated from which the framework insantiates a system and the third is a package containing concrete Device and Protocol implementations used by the system. ","category":"page"},{"location":"installation.html#Julia-Package","page":"Installation","title":"Julia Package","text":"","category":"section"},{"location":"installation.html","page":"Installation","title":"Installation","text":"To use the framework, you need to install to install MPIMeasurements.jl within Julia. To this end, start julia and open the package mode by entering ]. Then enter","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"add MPIMeasurements","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"This will install the latest version of MPIMeasurements.jl and all its dependencies. Alternatively one can also use ","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"dev MPIMeasurements","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"to add the package in development mode. This installs a full clone of the packages repository, which can then be changed and adapted. However, in this latter case the version control is fully the users responsiblity.","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"To use specific versions of the framework or to read more information about package mangement, please consult the Pkg documentation.","category":"page"},{"location":"installation.html#Scanner-Configuration-Files","page":"Installation","title":"Scanner Configuration Files","text":"","category":"section"},{"location":"installation.html","page":"Installation","title":"Installation","text":"Each Scanner in MPIMeasurements.jl is associated with a directory containing a set of configuration files in the TOML format. Per default the framwork searches for these directories in two locations: The config located in the packages file structure itself and the users home directory under .mpi/Scanners. However, it is also possible to add new configuration paths that are considered by the framework.","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"It is recommended that a user creates the following directory structure in their home directory:","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":".mpi/\n├── Scanners/\n│   └── <Example Scanner Name>\n│   └── ...\n└── Logs/","category":"page"},{"location":"installation.html","page":"Installation","title":"Installation","text":"It is also recommended to place the individual scanner directories or the entire Scanners/ subdirectory under version control.","category":"page"},{"location":"installation.html#(Private)-Device-and-Protocol-Implementations","page":"Installation","title":"(Private) Device and Protocol Implementations","text":"","category":"section"},{"location":"installation.html","page":"Installation","title":"Installation","text":"MPIMeasurements.jl instantiates a Scanner based on its configuration files. These files describe the used Devices and their dependencies and in turn Device implementations are constructed. While MPIMeasurements itself contains several concrete Device and Protocol implementations, it is also possible to add (and develop) other (private) Julia packages that contain and extend more implementations.","category":"page"},{"location":"lib/public.html#Public-Documentation","page":"Public Documentation","title":"Public Documentation","text":"","category":"section"},{"location":"lib/public.html","page":"Public Documentation","title":"Public Documentation","text":"Documentation for MPIMeasurements.jl's public interface.","category":"page"},{"location":"lib/public.html","page":"Public Documentation","title":"Public Documentation","text":"See the Internals section of the manual for internal package docs covering all submodules.","category":"page"},{"location":"lib/public.html#Contents","page":"Public Documentation","title":"Contents","text":"","category":"section"},{"location":"lib/public.html","page":"Public Documentation","title":"Public Documentation","text":"Pages = [\"public.md\"]","category":"page"},{"location":"lib/public.html#Index","page":"Public Documentation","title":"Index","text":"","category":"section"},{"location":"lib/public.html","page":"Public Documentation","title":"Public Documentation","text":"Pages = [\"public.md\"]","category":"page"},{"location":"lib/public.html#Public-Interface","page":"Public Documentation","title":"Public Interface","text":"","category":"section"},{"location":"lib/public.html#MPIMeasurements.concreteTypesCache","page":"Public Documentation","title":"MPIMeasurements.concreteTypesCache","text":"Retrieve the concrete type of a given supertype corresponding to a given string.\n\n\n\n\n\n","category":"constant"},{"location":"lib/public.html#MPIMeasurements.iselErrorCodes","page":"Public Documentation","title":"MPIMeasurements.iselErrorCodes","text":"Errorcodes Isel Robot \n\n\n\n\n\n","category":"constant"},{"location":"lib/public.html#MPIMeasurements.AbstractDeviceException","page":"Public Documentation","title":"MPIMeasurements.AbstractDeviceException","text":"Abstract exception type for exceptions in devices\n\n\n\n\n\n","category":"type"},{"location":"lib/public.html#MPIMeasurements.AcquisitionSettings","page":"Public Documentation","title":"MPIMeasurements.AcquisitionSettings","text":"Settings for acquiring the sequence.\n\n\n\n\n\n","category":"type"},{"location":"lib/public.html#MPIMeasurements.BrukerCommand","page":"Public Documentation","title":"MPIMeasurements.BrukerCommand","text":"BrukerCommand(command::String) \n\n\n\n\n\n","category":"type"},{"location":"lib/public.html#MPIMeasurements.ConfigurationError","page":"Public Documentation","title":"MPIMeasurements.ConfigurationError","text":"Abstract error type for errors in configuration files\n\n\n\n\n\n","category":"type"},{"location":"lib/public.html#MPIMeasurements.Device","page":"Public Documentation","title":"MPIMeasurements.Device","text":"Abstract type for all devices\n\nEvery device has to implement its own device struct which identifies it. A concrete implementation should contain e.g. the handle to device ressources or internal variables. The device struct must at least have the fields deviceID, params and dependencies and all other fields should have default values.\n\n\n\n\n\n","category":"type"},{"location":"lib/public.html#MPIMeasurements.Device-Tuple{String, String}","page":"Public Documentation","title":"MPIMeasurements.Device","text":"Device(scannerName, deviceID; kwargs...)\n\n\nInitialize and retrieve a device by its deviceID from a scanners configuration file. Also initializes the devices dependency tree according to the initialization order defined in the configuration file.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.DeviceException","page":"Public Documentation","title":"MPIMeasurements.DeviceException","text":"General exception type for exceptions in devices\n\n\n\n\n\n","category":"type"},{"location":"lib/public.html#MPIMeasurements.DeviceParams","page":"Public Documentation","title":"MPIMeasurements.DeviceParams","text":"Abstract type for all device parameters\n\nEvery device must implement a parameter struct allowing for automatic instantiation from the configuration file.\n\n\n\n\n\n","category":"type"},{"location":"lib/public.html#MPIMeasurements.FOTemp-Tuple{AbstractString}","page":"Public Documentation","title":"MPIMeasurements.FOTemp","text":"fotemp(portAdress::AbstractString)\n\nInitialize Fotemp fiber optical temperature sensor. For an overview over the high level API call methodswith(SerialDevice{FOTemp}).\n\nLow level functions such as getModelName(ft) will return a function hash and a whitespace, e.g. \"#40 \" leading the actual answer, which would be the model name of the device in this case.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.IgusRobotParams","page":"Public Documentation","title":"MPIMeasurements.IgusRobotParams","text":"Parameters for a Robot of type IgusRobot\n\ndefaultVelocity\naxisRange\nip\nport\nkeepSocketOpen\nstepsPermm\nfeed\nshaftRev\nhomVelSwitch\nhomVelZero\nhomAcc\nmovAcc\nmovDec\ntimeout\nnamedPositions\ncoordinateSystem\n\n\n\n\n\n","category":"type"},{"location":"lib/public.html#MPIMeasurements.IselRobotPoolParams","page":"Public Documentation","title":"MPIMeasurements.IselRobotPoolParams","text":"Parameters for a Robot of type IselRobot that is connected via a serial port pool\n\naxisRange\ndefaultVel\ndefaultRefVel\ninvertAxes\nminMaxVel\nminMaxAcc\nminMaxFreq\nstepsPermm\nroundmmDigits\ndescription\ndelim_read\ndelim_write\nbaudrate\nndatabits\nparity\nnstopbits\ntimeout_ms\nnamedPositions\nreferenceOrder\nmovementOrder\ncoordinateSystem\nenableWaitTime\n\n\n\n\n\n","category":"type"},{"location":"lib/public.html#MPIMeasurements.IselRobotPortParams","page":"Public Documentation","title":"MPIMeasurements.IselRobotPortParams","text":"Parameters for a Robot of type IselRobot that is connected directly via a serial port\n\naxisRange\ndefaultVel\ndefaultRefVel\ninvertAxes\nminMaxVel\nminMaxAcc\nminMaxFreq\nstepsPermm\nroundmmDigits\nserial_port\ndelim_read\ndelim_write\nbaudrate\nndatabits\nparity\nnstopbits\ntimeout_ms\nnamedPositions\nreferenceOrder\nmovementOrder\ncoordinateSystem\nenableWaitTime\n\n\n\n\n\n","category":"type"},{"location":"lib/public.html#MPIMeasurements.LakeShoreF71GaussMeter","page":"Public Documentation","title":"MPIMeasurements.LakeShoreF71GaussMeter","text":"\n\n\n\n","category":"type"},{"location":"lib/public.html#MPIMeasurements.Protocol","page":"Public Documentation","title":"MPIMeasurements.Protocol","text":"Abstract type for all protocols\n\nEvery protocol has to implement its own protocol struct which identifies it. A concrete implementation should contain e.g. the handle to the datastore or internal variables. The device struct must at least have the fields name, description, scanner and params and all other fields should have default values.\n\n\n\n\n\n","category":"type"},{"location":"lib/public.html#MPIMeasurements.Protocol-Tuple{Dict{String, Any}, MPIScanner}","page":"Public Documentation","title":"MPIMeasurements.Protocol","text":"General constructor for all concrete subtypes of Protocol.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.ProtocolConfigurationError","page":"Public Documentation","title":"MPIMeasurements.ProtocolConfigurationError","text":"Specialized error type for errors in protocol configuration files\n\n\n\n\n\n","category":"type"},{"location":"lib/public.html#MPIMeasurements.ProtocolOffsetElectricalChannel","page":"Public Documentation","title":"MPIMeasurements.ProtocolOffsetElectricalChannel","text":"Offset channnel that gets translated into the correct representation by the MPSMeasurementProtocol\n\nid: ID corresponding to the channel configured in the scanner.\noffsetStart\noffsetStop\nnumOffsets\n\n\n\n\n\n","category":"type"},{"location":"lib/public.html#MPIMeasurements.RedPitayaDAQParams-Tuple{Dict{String, Any}}","page":"Public Documentation","title":"MPIMeasurements.RedPitayaDAQParams","text":"Create the params struct from a dict. Typically called during scanner instantiation.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.RxChannel","page":"Public Documentation","title":"MPIMeasurements.RxChannel","text":"Receive channel reference that should be included in the acquisition.\n\n\n\n\n\n","category":"type"},{"location":"lib/public.html#MPIMeasurements.ScannerConfigurationError","page":"Public Documentation","title":"MPIMeasurements.ScannerConfigurationError","text":"Specialized error type for errors in scanner configuration files\n\n\n\n\n\n","category":"type"},{"location":"lib/public.html#MPIMeasurements.Sequence","page":"Public Documentation","title":"MPIMeasurements.Sequence","text":"Description of a sequence that can be run by a scanner.\n\nThe sequence can either be continuous or triggered. Triggered in this context means that the acquisition is done on a certain event, e.g. the move of a robot. The sweeping of frequencies or movement points can also be done in a triggered or continuous fashion.\n\n\n\n\n\n","category":"type"},{"location":"lib/public.html#MPIMeasurements.Sequence-Tuple{AbstractString, AbstractString}","page":"Public Documentation","title":"MPIMeasurements.Sequence","text":"Sequence(configdir, name)\n\n\nConstructor for a sequence of name from configDir.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.SequenceConfigurationError","page":"Public Documentation","title":"MPIMeasurements.SequenceConfigurationError","text":"Specialized error type for errors in sequence configuration files\n\n\n\n\n\n","category":"type"},{"location":"lib/public.html#MPIMeasurements.SimpleBoreCollisionModuleParams","page":"Public Documentation","title":"MPIMeasurements.SimpleBoreCollisionModuleParams","text":"Parameters for a SimpleBoreCollisionModule`\n\nscannerDiameter: Diameter of scanner in the y-z plane\nobjGeometry: Geometry of the probe, centered at (0,0,0) in scanner coordinates\nclearance\nminMaxBoreAxis: Define the minimum and maximum points of movement into and out of the bore axis (x)\n\n\n\n\n\n","category":"type"},{"location":"lib/public.html#MPIMeasurements.SimpleSimulatedDAQParams-Tuple{Dict{String, Any}}","page":"Public Documentation","title":"MPIMeasurements.SimpleSimulatedDAQParams","text":"Create the params struct from a dict. Typically called during scanner instantiation.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.TCPSCPIInstrument-Tuple{String, Integer}","page":"Public Documentation","title":"MPIMeasurements.TCPSCPIInstrument","text":"Constructor interpreting the given ip string as a IPv4 address\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.Waveform","page":"Public Documentation","title":"MPIMeasurements.Waveform","text":"Enum describing the existing waveforms.\n\n\n\n\n\n","category":"type"},{"location":"lib/public.html#Base.close-Tuple{MPIMeasurements.SerialDevice}","page":"Public Documentation","title":"Base.close","text":"Close the serial port of the serial device sd.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#Base.close-Tuple{MPIScanner}","page":"Public Documentation","title":"Base.close","text":"close(scanner)\n\n\nClose the devices when closing the scanner.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#Base.show-Tuple{IO, MPIMeasurements.ConfigurationError}","page":"Public Documentation","title":"Base.show","text":"Base.show(io::IO, ex::ConfigurationError)\n\nCustom printing of ConfigurationError subtypes\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#Base.show-Tuple{IO, MPIMeasurements.DeviceException}","page":"Public Documentation","title":"Base.show","text":"Base.show(io::IO, ex::DeviceException)\n\nCustom printing of DeviceException\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.Devices-Tuple{String, Vector{String}}","page":"Public Documentation","title":"MPIMeasurements.Devices","text":"Devices(scannerName, deviceIDs; kwargs...)\n\n\nInitialize and retrieve devices by theirdeviceID from a scanners configuration file. Also initializes the devices dependency trees according to the initialization order defined in the configuration file..\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.__init__-Tuple{}","page":"Public Documentation","title":"MPIMeasurements.__init__","text":"__init__()\n\n\nInitialize configuration paths with the package and enable MPI REPL mode.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements._moveRel-Tuple{BrukerRobot, Vector{<:Union{Quantity{T, 𝐋, U}, Level{L, S, Quantity{T, 𝐋, U}} where {L, S}} where {T, U}}, Union{Nothing, Vector{<:Union{Quantity{T, 𝐋 𝐓^-1, U}, Level{L, S, Quantity{T, 𝐋 𝐓^-1, U}} where {L, S}} where {T, U}}}}","page":"Public Documentation","title":"MPIMeasurements._moveRel","text":"Not Implemented \n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.checkCollisionYZCircle-Tuple{Geometry, Vararg{Union{Quantity{T, 𝐋, U}, Level{L, S, Quantity{T, 𝐋, U}} where {L, S}} where {T, U}, 4}}","page":"Public Documentation","title":"MPIMeasurements.checkCollisionYZCircle","text":"Returns true, 0mm, 0mm if given geometry does not collide with the scanner radius based on  given position and clearance\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.checkCoords-Tuple{AbstractCollisionModule3D, AbstractMatrix{<:Union{Quantity{T, 𝐋, U}, Level{L, S, Quantity{T, 𝐋, U}} where {L, S}} where {T, U}}}","page":"Public Documentation","title":"MPIMeasurements.checkCoords","text":"Convenience function to check an array of nx3 position vectors at once\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.checkCoords-Tuple{Vector{<:AbstractCollisionModule}, Vararg{Any}}","page":"Public Documentation","title":"MPIMeasurements.checkCoords","text":"if the function is called on a vector of collision modules return the logic AND of all decisions\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.checkPosition-Tuple{Robot, ScannerCoords}","page":"Public Documentation","title":"MPIMeasurements.checkPosition","text":"Returns true if given position is allowed, false otherwise\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.command-Tuple{SerialSCPIInstrument, String}","page":"Public Documentation","title":"MPIMeasurements.command","text":"Send a command to the instrument\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.command-Tuple{TCPSCPIInstrument, String}","page":"Public Documentation","title":"MPIMeasurements.command","text":"Send a command to the instrument\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.configDir-Tuple{Device}","page":"Public Documentation","title":"MPIMeasurements.configDir","text":"Retrieve the configuration directory of the scanner that the device is contructed from.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.configDir-Tuple{MPIScanner}","page":"Public Documentation","title":"MPIMeasurements.configDir","text":"Path to the used configuration directory.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.configFile-Tuple{Device}","page":"Public Documentation","title":"MPIMeasurements.configFile","text":"Retrieve the path to the configuration file of a device.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.configFile-Tuple{MPIScanner}","page":"Public Documentation","title":"MPIMeasurements.configFile","text":"Path to the used configuration file\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.createDAQChannels-Tuple{Dict{String, Any}}","page":"Public Documentation","title":"MPIMeasurements.createDAQChannels","text":"Create DAQ channel description from device dict part.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.createDAQParams-Union{Tuple{T}, Tuple{Type{T}, Dict{String, Any}}} where T<:DAQParams","page":"Public Documentation","title":"MPIMeasurements.createDAQParams","text":"Create the params struct from a dict. Typically called during scanner instantiation.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.createModbusTelegram-Tuple{@NamedTuple{addr::UInt16, subidx::UInt8, bytes::UInt8}, Integer}","page":"Public Documentation","title":"MPIMeasurements.createModbusTelegram","text":"createModbusTelegram(sdoObject::SDOObj, data::Integer)\n\nCreates a TCP payload that will write data into the given sdoObject\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.createModbusTelegram-Tuple{@NamedTuple{addr::UInt16, subidx::UInt8, bytes::UInt8}}","page":"Public Documentation","title":"MPIMeasurements.createModbusTelegram","text":"createModbusTelegram(sdoObject::SDOObj)\n\nCreates a TCP payload that will be identified as a read-only modbus command by the motor controller\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.createRFFTindices-Tuple{OrderedCollections.OrderedDict{PeriodicElectricalChannel, MPIMeasurements.TxChannelParams}, Sequence, AbstractDAQ}","page":"Public Documentation","title":"MPIMeasurements.createRFFTindices","text":"This function creates the correct indices into a channel-wise rfft of the reference channels for each channel in the controlledChannelsDict\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.createReferenceIndexMapping-Tuple{OrderedCollections.OrderedDict{PeriodicElectricalChannel, MPIMeasurements.TxChannelParams}, AbstractDAQ}","page":"Public Documentation","title":"MPIMeasurements.createReferenceIndexMapping","text":"Returns a vector of indices into the the DAQ data after the channels have already been selected by the daq.refChanIDs to select the correct reference channels in the order of the controlledChannels \n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.deepsubtypes-Tuple{Type}","page":"Public Documentation","title":"MPIMeasurements.deepsubtypes","text":"deepsubtypes(type)\n\n\nRecursively find all concrete types of the given type.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.defaultProtocol-Tuple{MPIScanner}","page":"Public Documentation","title":"MPIMeasurements.defaultProtocol","text":"Default protocol of the scanner.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.deviceID-Tuple{Device}","page":"Public Documentation","title":"MPIMeasurements.deviceID","text":"Retrieve the ID of a device.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.expectedDependencies-Tuple{Device}","page":"Public Documentation","title":"MPIMeasurements.expectedDependencies","text":"Retrieve all expected dependencies of a device.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.generalParams-Tuple{MPIScanner}","page":"Public Documentation","title":"MPIMeasurements.generalParams","text":"General parameters of the scanner like its bore size or gradient.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.getActiveChannel-Tuple{LakeShore460GaussMeter}","page":"Public Documentation","title":"MPIMeasurements.getActiveChannel","text":"Returns the active channel X, Y, Z, V = Vector Magnitude Channel\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.getActiveChannels-Tuple{FOTemp}","page":"Public Documentation","title":"MPIMeasurements.getActiveChannels","text":"Returns the the active channels. The active and inactive channels are the bits of the ASCII encoded hexadecimal bytes returned after the whitespace following the function hash. I.e. \"#10 1E\" represents that channels 2, 3, 4, and 5 are on and the remaining channels 1,6,7, and 8 are switched off.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.getAllFields-Tuple{LakeShore460GaussMeter}","page":"Public Documentation","title":"MPIMeasurements.getAllFields","text":"Returns the field values of X, Y and Z. Throws an error if an overload was detected\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.getAveragedTemperature-Tuple{FOTemp, Char}","page":"Public Documentation","title":"MPIMeasurements.getAveragedTemperature","text":"Returns the averaged temperature of a channel.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.getAveragedTemperature-Tuple{FOTemp}","page":"Public Documentation","title":"MPIMeasurements.getAveragedTemperature","text":"Returns the averaged temperature of all channel.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.getControlResult-Tuple{MPIMeasurements.ControlSequence}","page":"Public Documentation","title":"MPIMeasurements.getControlResult","text":"Returns a Sequence that is merged from the control result and all uncontrolled field of the given ControlSequence\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.getDevice-Tuple{MPIScanner, String}","page":"Public Documentation","title":"MPIMeasurements.getDevice","text":"getDevice(scanner, deviceID)\n\n\nRetrieve a device by its deviceID.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.getDevice-Tuple{MPIScanner, Type{<:Device}}","page":"Public Documentation","title":"MPIMeasurements.getDevice","text":"getDevice(scanner, deviceType)\n\n\nRetrieve a device of a specific deviceType if it can be unambiguously retrieved. Returns nothing if no such device can be found and throws an error if multiple devices fit the type.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.getDeviceIDs-Tuple{MPIScanner}","page":"Public Documentation","title":"MPIMeasurements.getDeviceIDs","text":"getDeviceIDs(scanner)\n\n\nRetrieve a list of all device IDs available for the scanner.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.getDevices-Union{Tuple{T}, Tuple{MPIScanner, Type{T}}} where T<:Device","page":"Public Documentation","title":"MPIMeasurements.getDevices","text":"getDevices(scanner, deviceType)\n\n\nRetrieve all devices of a specific deviceType. Returns an empty vector if none are found\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.getFast-Tuple{LakeShore460GaussMeter}","page":"Public Documentation","title":"MPIMeasurements.getFast","text":"Fast data command mode query.  0 = on, 1 = off\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.getFirmwareVersion-Tuple{FOTemp}","page":"Public Documentation","title":"MPIMeasurements.getFirmwareVersion","text":"Returns the firmware version.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.getMeasuringChannels-Tuple{FOTemp}","page":"Public Documentation","title":"MPIMeasurements.getMeasuringChannels","text":"Returns the index of the active channel.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.getMode-Tuple{LakeShore460GaussMeter}","page":"Public Documentation","title":"MPIMeasurements.getMode","text":"Returns the mode of the active channel DC = 0 AC = 1\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.getModelName-Tuple{FOTemp}","page":"Public Documentation","title":"MPIMeasurements.getModelName","text":"Returns the model name of the device.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.getPeakRMS-Tuple{LakeShore460GaussMeter}","page":"Public Documentation","title":"MPIMeasurements.getPeakRMS","text":"Returns the AC Mode RMS = 0, Peak = 1\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.getProbeType-Tuple{LakeShore460GaussMeter}","page":"Public Documentation","title":"MPIMeasurements.getProbeType","text":"Returns the type of the probe \t0 = High Sensitivity (HSE) \t1 = High Stability (HST) \t2 = Ultra-High Sensitivity (UHS)\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.getRange-Tuple{LakeShore460GaussMeter}","page":"Public Documentation","title":"MPIMeasurements.getRange","text":"Returns the range of the active channel. The range depends on the installed probe. For HSE Probe. More Information in part 3.4 on page 3-7. \t0 = highest = ±3T \t1           = ±300mT \t2           = ±30mT \t3 = lowest  = ±3mT\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.getSdoObject-Tuple{IgusRobot, @NamedTuple{addr::UInt16, subidx::UInt8, bytes::UInt8}}","page":"Public Documentation","title":"MPIMeasurements.getSdoObject","text":"getSdoObject(rob::IgusRobot, sdoObject::SDOObj)\n\nQueries the rob and returns the value of the chosen sdoObject\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.getSequenceList-Tuple{MPIScanner}","page":"Public Documentation","title":"MPIMeasurements.getSequenceList","text":"getSequenceList(scanner)\n\n\nRetrieve a list of all sequences available for the scanner.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.getSerialDevices-Tuple{}","page":"Public Documentation","title":"MPIMeasurements.getSerialDevices","text":"Read out current Serial Ports, returns Array{String,1}\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.getSerialNumber-Tuple{FOTemp}","page":"Public Documentation","title":"MPIMeasurements.getSerialNumber","text":"Returns the model name of the device.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.getTemperature-Tuple{FOTemp, Int64}","page":"Public Documentation","title":"MPIMeasurements.getTemperature","text":"Returns the current temperature of a channel.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.getTemperature-Tuple{FOTemp}","page":"Public Documentation","title":"MPIMeasurements.getTemperature","text":"Returns the current temperature of all channel.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.getTemperatureAveraging-Tuple{FOTemp, Char}","page":"Public Documentation","title":"MPIMeasurements.getTemperatureAveraging","text":"Returns the averaging count of a given channel.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.getUnit-Tuple{LakeShore460GaussMeter}","page":"Public Documentation","title":"MPIMeasurements.getUnit","text":"Returns the active used unit G = gauss, T = tesla\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.getXYZValues-Tuple{GaussMeter}","page":"Public Documentation","title":"MPIMeasurements.getXYZValues","text":"Returns x,y, and z values and applies a coordinate transformation\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.getXYZValues-Tuple{LakeShore460GaussMeter}","page":"Public Documentation","title":"MPIMeasurements.getXYZValues","text":"Returns x,y, and z values and apply a coordinate transformation\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.hasDependency-Tuple{Device, DataType}","page":"Public Documentation","title":"MPIMeasurements.hasDependency","text":"Check whether the device has a dependency of the given type.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.identification-Tuple{LakeShore460GaussMeter}","page":"Public Documentation","title":"MPIMeasurements.identification","text":"Returns the manufacturerID, model number, derial number and firmware revision date\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.init","page":"Public Documentation","title":"MPIMeasurements.init","text":"init(scanner; ...)\ninit(scanner, deviceIDs; kwargs...)\n\n\n(Re-)initializes the given devices of a Scanner according to the current configuration file. This also initializes all dependencies of the given devices. This does not initialize devices that themselves depend on the given devices.\n\n\n\n\n\n","category":"function"},{"location":"lib/public.html#MPIMeasurements.initAxes","page":"Public Documentation","title":"MPIMeasurements.initAxes","text":"Initializes all axes in order Z,Y,X \n\n\n\n\n\n","category":"function"},{"location":"lib/public.html#MPIMeasurements.initiateDevices-Tuple{AbstractString, Dict{String, Any}}","page":"Public Documentation","title":"MPIMeasurements.initiateDevices","text":"initiateDevices(configDir, devicesParams; robust, order)\n\n\nInitiate devices from the given configuration dictionary.\n\nThe device types are referenced by strings matching their device struct name. All device structs are supplied with the device ID and the corresponding device configuration struct.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.invertAxesYZ-Tuple{IselRobot}","page":"Public Documentation","title":"MPIMeasurements.invertAxesYZ","text":"Inverts the axes for y,z \n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.invertAxisZ-Tuple{IselRobot}","page":"Public Documentation","title":"MPIMeasurements.invertAxisZ","text":"Inverts the axis for z \n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.isAutoRanging-Tuple{LakeShore460GaussMeter}","page":"Public Documentation","title":"MPIMeasurements.isAutoRanging","text":"Returns the state of auto ranging for the active channel\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.isExpectedDependency-Tuple{Device, Device}","page":"Public Documentation","title":"MPIMeasurements.isExpectedDependency","text":"Check if a device is an expected dependency of another device.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.isFieldComp-Tuple{LakeShore460GaussMeter}","page":"Public Documentation","title":"MPIMeasurements.isFieldComp","text":"Returns the state of the field compensation\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.isInSleepMode-Tuple{LakeShore460GaussMeter}","page":"Public Documentation","title":"MPIMeasurements.isInSleepMode","text":"Returns the sleep mode status of the gaussmeter\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.isLocked-Tuple{LakeShore460GaussMeter}","page":"Public Documentation","title":"MPIMeasurements.isLocked","text":"Returns the state of the frontpanel lock\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.isOptional-Tuple{Device}","page":"Public Documentation","title":"MPIMeasurements.isOptional","text":"Check whether the device is optional.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.isPresent-Tuple{Device}","page":"Public Documentation","title":"MPIMeasurements.isPresent","text":"Check whether the device is present.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.isProbeOn-Tuple{LakeShore460GaussMeter}","page":"Public Documentation","title":"MPIMeasurements.isProbeOn","text":"Returns the state of the probe of the active channel\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.isTempComp-Tuple{LakeShore460GaussMeter}","page":"Public Documentation","title":"MPIMeasurements.isTempComp","text":"Returns the state of the temperatur compensation\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.lockOff-Tuple{LakeShore460GaussMeter}","page":"Public Documentation","title":"MPIMeasurements.lockOff","text":"Unlocks the frontpanel\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.lockOn-Tuple{LakeShore460GaussMeter}","page":"Public Documentation","title":"MPIMeasurements.lockOn","text":"Locks the frontpanel\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.moveCenter-Tuple{BrukerRobot}","page":"Public Documentation","title":"MPIMeasurements.moveCenter","text":"Move Bruker Robot to center\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.movePark-Tuple{BrukerRobot}","page":"Public Documentation","title":"MPIMeasurements.movePark","text":"Move Bruker Robot to park\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.name-Tuple{MPIScanner}","page":"Public Documentation","title":"MPIMeasurements.name","text":"Name of the scanner\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.numChannels-Tuple{FOTemp}","page":"Public Documentation","title":"MPIMeasurements.numChannels","text":"Returns the number of channels the device has.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.params-Tuple{Device}","page":"Public Documentation","title":"MPIMeasurements.params","text":"Retrieve the parameters of a device.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.query-Tuple{MPIMeasurements.SerialDevice, Any}","page":"Public Documentation","title":"MPIMeasurements.query","text":"Send querry to serial device and receive device answer. Returns a String\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.query-Tuple{SerialSCPIInstrument, String, Type}","page":"Public Documentation","title":"MPIMeasurements.query","text":"Perform a query to the instrument. Parse result as type T.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.query-Tuple{SerialSCPIInstrument, String}","page":"Public Documentation","title":"MPIMeasurements.query","text":"Perform a query to the instrument. Return String.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.query-Tuple{TCPSCPIInstrument, String, Type}","page":"Public Documentation","title":"MPIMeasurements.query","text":"Perform a query to the iunstrument. Parse result as type T.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.query-Tuple{TCPSCPIInstrument, String}","page":"Public Documentation","title":"MPIMeasurements.query","text":"Perform a query to the instrument. Return String.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.queryIsel","page":"Public Documentation","title":"MPIMeasurements.queryIsel","text":"queryIsel(sd::SerialDevice,cmd::String) \n\n\n\n\n\n","category":"function"},{"location":"lib/public.html#MPIMeasurements.readIOInput-Tuple{IselRobot, Int64}","page":"Public Documentation","title":"MPIMeasurements.readIOInput","text":"readIOInput(robot::IselRobot,input::Int64) returns an Bool for the input slot\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.readIOInput-Tuple{IselRobot}","page":"Public Documentation","title":"MPIMeasurements.readIOInput","text":"readIOInput(robot::IselRobot) returns an Array{Bool,1} of the 1-8 input slots\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.readModbusTelegram-Tuple{Vector{UInt8}}","page":"Public Documentation","title":"MPIMeasurements.readModbusTelegram","text":"readModbusTelegram(telegram::Vector{UInt8})\n\nChecks the received telegram for error codes and returns the data payload\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.receive-Tuple{MPIMeasurements.SerialDevice}","page":"Public Documentation","title":"MPIMeasurements.receive","text":"Read out current content of the output buffer of the serial devive. Returns a String.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.scannerBoreSize-Tuple{MPIScanner}","page":"Public Documentation","title":"MPIMeasurements.scannerBoreSize","text":"Bore size of the scanner.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.scannerDatasetStore-Tuple{MPIScanner}","page":"Public Documentation","title":"MPIMeasurements.scannerDatasetStore","text":"Path of the dataset store.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.scannerFacility-Tuple{MPIScanner}","page":"Public Documentation","title":"MPIMeasurements.scannerFacility","text":"Facility where the scanner is located.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.scannerGradient-Tuple{MPIScanner}","page":"Public Documentation","title":"MPIMeasurements.scannerGradient","text":"Gradient of the scanners selection field.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.scannerManufacturer-Tuple{MPIScanner}","page":"Public Documentation","title":"MPIMeasurements.scannerManufacturer","text":"Manufacturer of the scanner.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.scannerName-Tuple{MPIScanner}","page":"Public Documentation","title":"MPIMeasurements.scannerName","text":"Name of the scanner\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.scannerTopology-Tuple{MPIScanner}","page":"Public Documentation","title":"MPIMeasurements.scannerTopology","text":"Topology of the scanner, e.g. FFL or FFP.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.selfTest-Tuple{LakeShore460GaussMeter}","page":"Public Documentation","title":"MPIMeasurements.selfTest","text":"The gaussmeter reports status based on test done at power up. 0 = no erors found, 1= erros found\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.sendAndReceiveTelegram-Tuple{IgusRobot, Vector{UInt8}}","page":"Public Documentation","title":"MPIMeasurements.sendAndReceiveTelegram","text":"sendAndReceiveTelegram(rob::IgusRobot, telegram::Vector{UInt8})\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.sendCommand-Tuple{BrukerRobot, MPIMeasurements.BrukerCommand}","page":"Public Documentation","title":"MPIMeasurements.sendCommand","text":"Send Command sendCommand(sd::BrukerRobot, brukercmd::BrukerCommand)\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.setAcceleration-Tuple{IselRobot, MPIMeasurements.IselControllerVersion, Any}","page":"Public Documentation","title":"MPIMeasurements.setAcceleration","text":"Sets Acceleration \n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.setActiveChannel-Tuple{FOTemp, String}","page":"Public Documentation","title":"MPIMeasurements.setActiveChannel","text":"Sets the active channels. The parameter channel encodes the switched on and off channels. The bits of the ASCII encoded hexadecimal bytes are the channels, with bit 0 representing channel 1 to bit 7 for channel 8.\n\nFor example channel=\"1E\" will switch on channels 2, 3, 4, and 5 and switch off the remaining channels 1,6,7, and 8.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.setActiveChannel-Tuple{LakeShore460GaussMeter, Char}","page":"Public Documentation","title":"MPIMeasurements.setActiveChannel","text":"Sets the active channel to X, Y, Z, V = Vector Magnitude Channel\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.setAllAutoRanging-Tuple{LakeShore460GaussMeter, Char}","page":"Public Documentation","title":"MPIMeasurements.setAllAutoRanging","text":"Set auto ranging of all channels\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.setAllMode-Tuple{LakeShore460GaussMeter, Char}","page":"Public Documentation","title":"MPIMeasurements.setAllMode","text":"Set the mode of all channels DC = 0, AC = 1\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.setAllRange-Tuple{LakeShore460GaussMeter, Int64}","page":"Public Documentation","title":"MPIMeasurements.setAllRange","text":"Sets the range of all channels\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.setAutoRanging-Tuple{LakeShore460GaussMeter, Char}","page":"Public Documentation","title":"MPIMeasurements.setAutoRanging","text":"Set state of auto ranging for the active channel\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.setBrake-Tuple{IselRobot, Bool}","page":"Public Documentation","title":"MPIMeasurements.setBrake","text":"Sets brake, brake=false no current on brake , brake=true current on brake \n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.setCompleteProbe-Tuple{LakeShore460GaussMeter, Char}","page":"Public Documentation","title":"MPIMeasurements.setCompleteProbe","text":"Sets complete probe on = 0 or off = 1\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.setFast-Tuple{LakeShore460GaussMeter, Char}","page":"Public Documentation","title":"MPIMeasurements.setFast","text":"Set fast data command mode.  0 = on, 1 = off\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.setFieldComp-Tuple{LakeShore460GaussMeter, Char}","page":"Public Documentation","title":"MPIMeasurements.setFieldComp","text":"Set the state of the field compensation. 1 = on, 0 = off\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.setFree-Tuple{IselRobot, MPIMeasurements.IselControllerVersion, Any}","page":"Public Documentation","title":"MPIMeasurements.setFree","text":"Sets free, Freifahren axis, wenn Achse über den Referenzpunkt gefahren ist\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.setFrontPanelLock-Tuple{LakeShore460GaussMeter, Char}","page":"Public Documentation","title":"MPIMeasurements.setFrontPanelLock","text":"sets the state of the front panel lock. Locks all entries except the alarm keys. 1 = on, 0 = off\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.setMode-Tuple{LakeShore460GaussMeter, Char, Char}","page":"Public Documentation","title":"MPIMeasurements.setMode","text":"Set the mode for the channel DC = 0 AC = 1\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.setPeakRMS-Tuple{LakeShore460GaussMeter, Char, Char}","page":"Public Documentation","title":"MPIMeasurements.setPeakRMS","text":"Set the AC mode for the channel RMS = 0, Peak = 1\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.setProbe-Tuple{LakeShore460GaussMeter, Char, Char}","page":"Public Documentation","title":"MPIMeasurements.setProbe","text":"Sets probe on = 0 or off = 1 on specific channel\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.setRange-Tuple{LakeShore460GaussMeter, Int64}","page":"Public Documentation","title":"MPIMeasurements.setRange","text":"Sets the range of the active channel. The range depends on the installed probe. For HSE Probe. More Information in part 3.4 on page 3-7. \t0 = highest = ±3T \t1           = ±300mT \t2           = ±30mT \t3 = lowest  = ±3mT\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.setRefVelocity-Tuple{IselRobot, Vector{<:Union{Quantity{T, 𝐋 𝐓^-1, U}, Level{L, S, Quantity{T, 𝐋 𝐓^-1, U}} where {L, S}} where {T, U}}}","page":"Public Documentation","title":"MPIMeasurements.setRefVelocity","text":"Sets the Reference velocities of the axes x,y,z \n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.setSdoObject-Tuple{IgusRobot, @NamedTuple{addr::UInt16, subidx::UInt8, bytes::UInt8}, Integer}","page":"Public Documentation","title":"MPIMeasurements.setSdoObject","text":"setSdoObject(rob::IgusRobot, sdoObject::SDOObj, value::Integer)\n\nQueries the rob and sets a new value for the chosen sdoObject\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.setSleepMode-Tuple{LakeShore460GaussMeter, Char}","page":"Public Documentation","title":"MPIMeasurements.setSleepMode","text":"Sets the sleep mode state of the gaussmeter.  0 = on, 1 = off\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.setStandardSettings-Tuple{LakeShore460GaussMeter}","page":"Public Documentation","title":"MPIMeasurements.setStandardSettings","text":"Sets the standard settings \t-highest range \t-unit to tesla \t-auto ranging off \t-complete probe on\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.setStartStopFreq-Tuple{IselRobot, MPIMeasurements.IselControllerVersion, Any}","page":"Public Documentation","title":"MPIMeasurements.setStartStopFreq","text":"Sets StartStopFrequency\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.setTempComp-Tuple{LakeShore460GaussMeter, Char}","page":"Public Documentation","title":"MPIMeasurements.setTempComp","text":"Set the state of the temperatur compensation. 1 = on, 0 = off\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.setTemperatureAveraging-Tuple{FOTemp, Char, Integer}","page":"Public Documentation","title":"MPIMeasurements.setTemperatureAveraging","text":"Sets the moving averaging count of a given channel to 0<numAverages<21.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.setTxParams","page":"Public Documentation","title":"MPIMeasurements.setTxParams","text":"Set the amplitude and phase for all the selected channels.\n\nNote: amplitudes and phases are defined as a dictionary of vectors, since every channel referenced by the dict's key could have a different amount of components.\n\n\n\n\n\n","category":"function"},{"location":"lib/public.html#MPIMeasurements.setUnit-Tuple{LakeShore460GaussMeter, Char}","page":"Public Documentation","title":"MPIMeasurements.setUnit","text":"Sets the active unit to 'G' = gauss, 'T' = tesla\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.setUnitToGauss-Tuple{LakeShore460GaussMeter}","page":"Public Documentation","title":"MPIMeasurements.setUnitToGauss","text":"Sets the unit of the values to gauss\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.setUnitToTesla-Tuple{LakeShore460GaussMeter}","page":"Public Documentation","title":"MPIMeasurements.setUnitToTesla","text":"Sets the unit of the values to tesla\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.setXRange-Tuple{LakeShore460GaussMeter, Int64}","page":"Public Documentation","title":"MPIMeasurements.setXRange","text":"Sets the range of the active channel. The range depends on the installed probe. For HSE Probe. More Information in part 3.4 on page 3-7. \t0 = highest = ±3T \t1           = ±300mT \t2           = ±30mT \t3 = lowest  = ±3mT\n\nSets the range of the X channel\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.setYRange-Tuple{LakeShore460GaussMeter, Int64}","page":"Public Documentation","title":"MPIMeasurements.setYRange","text":"Sets the range of the Y channel\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.setZRange-Tuple{LakeShore460GaussMeter, Int64}","page":"Public Documentation","title":"MPIMeasurements.setZRange","text":"Sets the range of the Z channel\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.setZeroPoint-Tuple{IselRobot}","page":"Public Documentation","title":"MPIMeasurements.setZeroPoint","text":"Sets the zero position for absolute moving at current axes position Z,Y,X \n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.set_delim_read-Tuple{MPIMeasurements.SerialDevice, String}","page":"Public Documentation","title":"MPIMeasurements.set_delim_read","text":"Set character which terminates query answer.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.set_delim_write-Tuple{MPIMeasurements.SerialDevice, String}","page":"Public Documentation","title":"MPIMeasurements.set_delim_write","text":"Set character which terminates query.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.set_timeout_ms-Tuple{MPIMeasurements.SerialDevice, Int64}","page":"Public Documentation","title":"MPIMeasurements.set_timeout_ms","text":"Set maximal time to wait for query answer in ms.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.simRefZYX-Tuple{IselRobot, MPIMeasurements.IselControllerVersion}","page":"Public Documentation","title":"MPIMeasurements.simRefZYX","text":"Simulates Reference Z,Y,X \n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.simulateLangevinInduced-Tuple{Vector{Quantity{Float64, 𝐓, Unitful.FreeUnits{(s,), 𝐓, nothing}}}, Vector{Quantity{Float64, 𝐌 𝐈^-1 𝐓^-2, Unitful.FreeUnits{(T,), 𝐌 𝐈^-1 𝐓^-2, nothing}}}, Quantity{Float64, 𝐓^-1, Unitful.FreeUnits{(Hz,), 𝐓^-1, nothing}}, Union{Quantity{Float64, NoDims, Unitful.FreeUnits{(rad,), NoDims, nothing}}, Vector{Quantity{Float64, NoDims, Unitful.FreeUnits{(rad,), NoDims, nothing}}}}}","page":"Public Documentation","title":"MPIMeasurements.simulateLangevinInduced","text":"Very, very basic simulation of an MPI signal using the Langevin function.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.sleepModeOff-Tuple{LakeShore460GaussMeter}","page":"Public Documentation","title":"MPIMeasurements.sleepModeOff","text":"Sets the sleep mode off\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.sleepModeOn-Tuple{LakeShore460GaussMeter}","page":"Public Documentation","title":"MPIMeasurements.sleepModeOn","text":"Sets the sleep mode on\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.toCurrentMode-Tuple{Amplifier}","page":"Public Documentation","title":"MPIMeasurements.toCurrentMode","text":"Sets the amplifier to current mode.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.toHighVoltageMode-Tuple{Amplifier}","page":"Public Documentation","title":"MPIMeasurements.toHighVoltageMode","text":"Sets the amplifier to high voltage mode.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.toLowVoltageMode-Tuple{Amplifier}","page":"Public Documentation","title":"MPIMeasurements.toLowVoltageMode","text":"Sets the amplifier to low voltage mode.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.toVoltageMode-Tuple{Amplifier}","page":"Public Documentation","title":"MPIMeasurements.toVoltageMode","text":"Sets the amplifier to voltage mode.\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#MPIMeasurements.writeIOOutput-Tuple{IselRobot, Vector{Bool}}","page":"Public Documentation","title":"MPIMeasurements.writeIOOutput","text":"writeIOOutput(robot::IselRobot,output::Array{Bool,1}) output represents 1-8 output slots\n\n\n\n\n\n","category":"method"},{"location":"lib/public.html#Sockets.send-Tuple{MPIMeasurements.SerialDevice, String}","page":"Public Documentation","title":"Sockets.send","text":"Send command string to serial device.\n\n\n\n\n\n","category":"method"},{"location":"config/sequence.html#Sequence-Parameters","page":"Sequences","title":"Sequence Parameters","text":"","category":"section"},{"location":"config/sequence.html#Magnetic-Field","page":"Sequences","title":"Magnetic Field","text":"","category":"section"},{"location":"config/sequence.html#MPIMeasurements.MagneticField","page":"Sequences","title":"MPIMeasurements.MagneticField","text":"Description of a magnetic field.\n\nThe field can either be electromagnetically or mechanically changed. The mechanical movement of e.g. an iron yoke would be defined within two channels, one electrical and one mechanical.\n\nid: Unique ID of the field description.\nchannels: Transmit channels that are used for the field.\nsafeStartInterval: Flag if the start of the field should be convoluted.   If the DAQ does not support this, it can may fall back   to postponing the application of the settings.   Not used for mechanical fields.\nsafeTransitionInterval: Flag if a transition of the field should be convoluted.   If the DAQ does not support this, it can may fall back   to postponing the application of the settings.   Not used for mechanical fields.\nsafeEndInterval: Flag if the end of the field should be convoluted. In case of an existing brake on   a mechanical channel this means a use of the brake.\nsafeErrorInterval: Flag if the field should be convoluted down in case of an error. In case of an   existing brake on a mechanical channel this means a use of the brake.\ncontrol: Flag if the channels of the field should be controlled.\ndecouple: Flag if the field should be decoupled. Not used for mechanical channels.\n\n\n\n\n\n","category":"type"},{"location":"config/sequence.html#Channels","page":"Sequences","title":"Channels","text":"","category":"section"},{"location":"config/sequence.html#MPIMeasurements.ContinuousElectricalChannel","page":"Sequences","title":"MPIMeasurements.ContinuousElectricalChannel","text":"Electrical channel with a stepwise definition of values.\n\n\n\n\n\n","category":"type"},{"location":"config/sequence.html#MPIMeasurements.ContinuousMechanicalRotationChannel","page":"Sequences","title":"MPIMeasurements.ContinuousMechanicalRotationChannel","text":"Mechanical channel with a continuous rotation.\n\n\n\n\n\n","category":"type"},{"location":"config/sequence.html#MPIMeasurements.ContinuousMechanicalTranslationChannel","page":"Sequences","title":"MPIMeasurements.ContinuousMechanicalTranslationChannel","text":"Mechanical channel describing a continuous translational movement.\n\n\n\n\n\n","category":"type"},{"location":"config/sequence.html#MPIMeasurements.PeriodicElectricalChannel","page":"Sequences","title":"MPIMeasurements.PeriodicElectricalChannel","text":"Electrical channel based on based on periodic base functions. Only the PeriodicElectricalChannel counts for the cycle length calculation\n\nid: ID corresponding to the channel configured in the scanner.\ncomponents: Components added for this channel.\noffset: Offset of the channel. If defined in Tesla, the calibration configured in the scanner will be used.\nisDfChannel\ndcEnabled\n\n\n\n\n\n","category":"type"},{"location":"config/sequence.html#MPIMeasurements.StepwiseElectricalChannel","page":"Sequences","title":"MPIMeasurements.StepwiseElectricalChannel","text":"Electrical channel with a stepwise definition of values.\n\nid: ID corresponding to the channel configured in the scanner.\ndivider: Divider of the component.\nvalues: Values corresponding to the individual steps.\nenable: TBD\n\n\n\n\n\n","category":"type"},{"location":"config/sequence.html#MPIMeasurements.StepwiseMechanicalRotationChannel","page":"Sequences","title":"MPIMeasurements.StepwiseMechanicalRotationChannel","text":"Mechanical channel with a triggered stepwise rotation.\n\n\n\n\n\n","category":"type"},{"location":"config/sequence.html#MPIMeasurements.StepwiseMechanicalTranslationChannel","page":"Sequences","title":"MPIMeasurements.StepwiseMechanicalTranslationChannel","text":"Mechanical channel describing a stepwise translational movement.\n\n\n\n\n\n","category":"type"},{"location":"config/sequence.html#Components","page":"Sequences","title":"Components","text":"","category":"section"},{"location":"config/sequence.html#MPIMeasurements.ArbitraryElectricalComponent","page":"Sequences","title":"MPIMeasurements.ArbitraryElectricalComponent","text":"Arbitrary waveform component of an electrical channel with periodic base function defined by a vector of 16384 values.\n\nid\ndivider: Divider of the component.\namplitude: Amplitude scale of the base waveform for each period of the field\nphase: Phase of the component for each period of the field.\nvalues: Values for the base waveform of the component, will be multiplied by amplitude\n\n\n\n\n\n","category":"type"},{"location":"config/sequence.html#MPIMeasurements.PeriodicElectricalComponent","page":"Sequences","title":"MPIMeasurements.PeriodicElectricalComponent","text":"Component of an electrical channel with periodic base function.\n\nid\ndivider: Divider of the component.\namplitude: Amplitude (peak) of the component for each period of the field.\nphase: Phase of the component for each period of the field.\nwaveform: Waveform of the component.\n\n\n\n\n\n","category":"type"},{"location":"config/sequence.html#MPIMeasurements.SweepElectricalComponent","page":"Sequences","title":"MPIMeasurements.SweepElectricalComponent","text":"Sweepable component of an electrical channel with periodic base function. Note: Does not allow for changes in phase since this would make the switch between frequencies difficult.\n\ndivider: Divider of the component.\namplitude: Amplitude (peak) of the channel for each divider in the sweep. Must have the same dimension as divider.\nwaveform: Waveform of the component.\n\n\n\n\n\n","category":"type"},{"location":"config/protocols.html#Protocols","page":"Protocols","title":"Protocols","text":"","category":"section"},{"location":"config/protocols.html#MPIMeasurements.ContinousMeasurementProtocolParams","page":"Protocols","title":"MPIMeasurements.ContinousMeasurementProtocolParams","text":"Parameters for the ContinousMeasurementProtocol`\n\nfgFrames: Foreground frames to measure. Overwrites sequence frames\nbgFrames: Background frames to measure. Overwrites sequence frames\npause: Pause between measurements\ncontrolTx: If set the tx amplitude and phase will be set with control steps\nmeasureBackground: If unset no background measurement will be taken\nsequence: Sequence to measure\n\n\n\n\n\n","category":"type"},{"location":"config/protocols.html#MPIMeasurements.MPIForceProtocolParams","page":"Protocols","title":"MPIMeasurements.MPIForceProtocolParams","text":"Parameters for the MPIForceProtocol\n\ncontrolTx: If set the tx amplitude and phase will be set with control steps\nsequence: Sequence to measure\n\n\n\n\n\n","category":"type"},{"location":"config/protocols.html#MPIMeasurements.MPIMeasurementProtocolParams","page":"Protocols","title":"MPIMeasurements.MPIMeasurementProtocolParams","text":"Parameters for the MPIMeasurementProtocol\n\nfgFrames: Foreground frames to measure. Overwrites sequence frames\nbgFrames: Background frames to measure. Overwrites sequence frames\ncontrolTx: If set the tx amplitude and phase will be set with control steps\nmeasureBackground: If unset no background measurement will be taken\nsaveTemperatureData: If the temperature should be safed or not\nsequence: Sequence to measure\nreuseLastBGMeas: Do not measure background but reuse the last BG measurement if suitable\n\n\n\n\n\n","category":"type"},{"location":"config/protocols.html#MPIMeasurements.MPSMeasurementProtocolParams","page":"Protocols","title":"MPIMeasurements.MPSMeasurementProtocolParams","text":"Parameters for the MPSMeasurementProtocol\n\nfgFrames: Foreground frames to measure. Overwrites sequence frames\nbgFrames: Background frames to measure. Overwrites sequence frames\ncontrolTx: If set the tx amplitude and phase will be set with control steps\nmeasureBackground: If unset no background measurement will be taken\nrememberBGMeas: Remember background measurement\nsaveTemperatureData: If the temperature should be saved or not\nsequence: Sequence to measure\nsortPatches: Sort patches\nsaveInCalibFolder: Flag if the measurement should be saved as a system matrix or not\ndfPeriodsPerOffset: Number of periods per offset of the MPS offset measurement. Overwrites parts of the sequence definition.\naveragePeriodsPerOffset: If true all periods per offset are averaged\n\n\n\n\n\n","category":"type"},{"location":"config/protocols.html#MPIMeasurements.MechanicalMPIMeasurementProtocolParams","page":"Protocols","title":"MPIMeasurements.MechanicalMPIMeasurementProtocolParams","text":"Parameters for the MechanicalMPIMeasurementProtocol\n\nfgFrames: Foreground frames to measure. Overwrites sequence frames\nbgFrames: Background frames to measure. Overwrites sequence frames\ncontrolTx: If set the tx amplitude and phase will be set with control steps\nmeasureBackground: If unset no background measurement will be taken\nsaveTemperatureData: If the temperature should be safed or not\nsequence: Sequence to measure\nrememberBGMeas: Remember background measurement\n\n\n\n\n\n","category":"type"},{"location":"config/protocols.html#MPIMeasurements.MultiSequenceSystemMatrixProtocolParams","page":"Protocols","title":"MPIMeasurements.MultiSequenceSystemMatrixProtocolParams","text":"Parameters for the MultiSequenceSystemMatrixProtocol\n\ncontrolTx: If set the tx amplitude and phase will be set with control steps\nsaveTemperatureData: If the temperature should be safed or not\nsequences: Sequences to measure\npositions: SM Positions mapped to the natural sorting of sequence tomls\nsaveInCalibFolder: Flag if the calibration should be saved as a system matrix or not\nwaitTime: Seconds to wait between measurements\ncoolDownTo: Maximum temperature the coils can be at to start the next measurement\nbgSequence: Sequence to use as a BG measurement\nnumBGMeas: Number of BG measurements before and after the measurement\n\n\n\n\n\n","category":"type"},{"location":"config/protocols.html#MPIMeasurements.RobotBasedMagneticFieldStaticProtocolParams","page":"Protocols","title":"MPIMeasurements.RobotBasedMagneticFieldStaticProtocolParams","text":"Parameter for the RobotBasedMagneticFieldStaticProtocol\n\nsequence\npositions\ndescription\n\n\n\n\n\n","category":"type"},{"location":"config/protocols.html#MPIMeasurements.RobotBasedSystemMatrixProtocolParams","page":"Protocols","title":"MPIMeasurements.RobotBasedSystemMatrixProtocolParams","text":"Parameters for the RobotBasedSystemMatrixProtocol\n\nwaitTime: Minimum wait time between robot movements\nbgFrames: Number of background frames to measure for a background position\nfgFrames: Number of frames that are averaged for a foreground position\nsaveAsSystemMatrix: Flag if the calibration should be saved as a system matrix or not\nsaveTemperatureData: Flag if the temperature measured after every robot measurement should be stored in the MDF or not\nbgMeas: Number of background measurements to take\ncontrolTx: If set the tx amplitude and phase will be set with control steps\nsequence: Sequence used for the calibration at each position\npositions\n\n\n\n\n\n","category":"type"},{"location":"config/protocols.html#MPIMeasurements.RobotBasedTDesignFieldProtocolParams","page":"Protocols","title":"MPIMeasurements.RobotBasedTDesignFieldProtocolParams","text":"Parameters for the RobotBasedTDesignFieldProtocol\n\nsequence\nradius\ncenter\nN\nT\n\n\n\n\n\n","category":"type"},{"location":"config/protocols.html#MPIMeasurements.RobotMPIMeasurementProtocolParams","page":"Protocols","title":"MPIMeasurements.RobotMPIMeasurementProtocolParams","text":"Parameters for the RobotMPIMeasurementProtocol\n\nfgPos: Foreground position\nfgFrames: Foreground frames to measure. Overwrites sequence frames\nbgFrames: Background frames to measure. Overwrites sequence frames\ncontrolTx: If set the tx amplitude and phase will be set with control steps\nmeasureBackground: If unset no background measurement will be taken\nsaveTemperatureData: If the temperature should be safed or not\nsequence: Sequence to measure\nrememberBGMeas: Remember background measurement\n\n\n\n\n\n","category":"type"},{"location":"framework/protocols.html#Protocols","page":"Protocols","title":"Protocols","text":"","category":"section"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"The purpose of a Protocol is to describe and implement a complex measurement procedure that may involve several Devices and Sequences, for example a robot-based system matrix calibration.","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"To achieve this, a Protocol acts as a running process, that controls all Devices of a scanner to perform its respective measurement. During its runtime a Protocol can spawn and join further processes, as well as react to user interaction and queries via a communication channel. This channel allows the same Protocol to be reused in scripts, console modes or GUIs.","category":"page"},{"location":"framework/protocols.html#Tasks-and-Channels","page":"Protocols","title":"Tasks and Channels","text":"","category":"section"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"Before devling into Protocols, let's review some necessary basics of asynchronous programming and multi-threading in Julia.","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"Julia provides Tasks (also called coroutines, lightweight or green threads). These are expressions or functions grouped as computation, that is executed as a \"thread\" which can be interrupted and switched out for a different Task. If Julia is started with multiple threads, for example with 5:","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"$ julia -t 5","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"then Tasks can run in parallel and on different threads. Depending on the Julia version and the way the Task was created, they can even migrate between threads.","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"The following example is a Task that prints the current id of the thread it is run on:","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"julia> t = Task(() -> println(Threads.threadid()))\nTask (runnable) @0x00007f5a378b2f80\n\njulia> schedule(t)\n1","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"After a Task is created, it needs to be scheduled before it is run. As a convience, the @async macro creates and immidiately schedules a Task:","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"@async println(Threads.threadid())\n1","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"Using the Julia package ThreadPools it is also possible to schedule a Task on a specific thread:","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"julia> @tspawnat 2 println(Threads.threadid())\n2","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"Once a Task is running, it is possible to wait for it to end in a blocking manner:","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"julia> t = @async sleep(3); println(Threads.threadid())\njulia> wait(t)","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"or a busy-waiting manner: ","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"julia> t = @async sleep(3); println(Threads.threadid())\njulia> while !istaskdone(t)\n          sleep(0.05)\n       end","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"If a Task threw an error during its runtime, a Task waiting on it will propagate the error. To check if a Task failed without waiting on it, one can use Base.istaskfailed and current_exceptions.","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"Another important concept for Protocols are Channel. These are waitable first-in-first-out (FIFO) queues which can be used to pass data between Tasks:","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"ch = Channel{Int64}(4) # Buffer up to 4 values\nput!(ch, 42) # Blocks if full\nisopen(ch) # True as long as the channel is open\nisready(ch) # True if channel contains values\nclose(ch)\nisopen(ch)\nisready(ch)\ntemp = take!(ch) # Blocks if empty\nisready(ch)\ntemp == 42","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"Multiple Tasks can read and write to a Channel, however this always goes into the same \"direction\". MPIMeasurements.jl provides a BidirectionalChannel, which encapsulates two Channels, allowing a Protocol to both receive and send data:","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"julia> ch = BidirectionalChannel{Int64}(4)\nBidirectionalChannel{Int64}(Channel{Int64}(4), Channel{Int64}(4))\n\njulia> ch2 = BidirectionalChannel(ch)\nBidirectionalChannel{Int64}(Channel{Int64}(4), Channel{Int64}(4))\n\njulia> put!(ch, 1)\n1\n\njulia> take!(ch2)\n1\n\njulia> put!(ch2, 2)\n2\n\njulia> take!(ch)\n2","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"Tasks and BidirectionalChannel are the main building blocks of Protocols.","category":"page"},{"location":"framework/protocols.html#Protocol-Structure","page":"Protocols","title":"Protocol Structure","text":"","category":"section"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"Protocols have a similar structure to Devices. Each Protocol has a parameter type that inherits from: ","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"abstract type ProtocolParams end","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"and must be named like the Protocol itself together with an Params suffix.","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"Similarily, each Protocol has a number of mandatory fields, that can be added with the provided macro add_protocol_fields. These fields contain the Scanner used by the Protocol, the name and description of the Protocol, its ProtocolParams and lastly its communication channel and its active main Task or process. ","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"Lastly, a Protocol can have any number of internal fields, these must be provided with a default value.","category":"page"},{"location":"framework/protocols.html#Protocol-Lifecycle","page":"Protocols","title":"Protocol Lifecycle","text":"","category":"section"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"Similar to a Sequence, a Protocol is constructed from a Scanners configuration directory: ","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"julia> protocol = Protocol(scanner, \"MPIMeasurementProtocol\")","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"This only constructs the Protocol and assigns it the value stored in its configuration file. One could now programmatically change the parameters of the Protocol.","category":"page"},{"location":"framework/protocols.html#Init","page":"Protocols","title":"Init","text":"","category":"section"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"The next step is to initialize a Protocol execution:","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"julia> init(protocol)","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"In this step MPIMeasurements.jl checks if the Protocol was constructed by a Scanner that contains all the necessary Devices required by the Protocol. Furthermore, it calls the _init function of the Protocol. In this function a Protocol implementation should check if all its arguments are sensible and prepare any internal fields it requires for an execution. This step should not start any Tasks. ","category":"page"},{"location":"framework/protocols.html#Execute","page":"Protocols","title":"Execute","text":"","category":"section"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"After its execution has been initialized, a Protocol can be started with:","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"julia> ch = execute(protocol)\nBidirectionalChannel{ProtocolEvent}(32)","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"This function checks if the Protocol is currently running and if not it starts a new execution. This involves creating a communication channel, which is returned at the end of the function and starting the Protocols Execution Task on a provided thread id (default 1). Once the execution Task is finished, the communication channel is closed.","category":"page"},{"location":"framework/protocols.html#Cleanup","page":"Protocols","title":"Cleanup","text":"","category":"section"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"If a Protocol produces temporary files, it can implement the cleanup function. After successfull Protocol execution, a calling Julia component can then invoke cleanup and remove any temporary files.","category":"page"},{"location":"framework/protocols.html#Protocol-Communication","page":"Protocols","title":"Protocol Communication","text":"","category":"section"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"During its execution a Protocol can communicate through its communication channel. From a caller perspective, this can be used to query the Protocol for its current progress, for its status or measurement data. It can also be used to ask the Protocol to pause and resume or to cancel. The Protocol itself can ask for things like a user confirmation or a user choice.","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"This communication however, is something that has to be deliberately implemented in a Protocol, though MPIMeasurements.jl provides several helper function for this cause. ","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"A Protocol communicates via ProtocolEvents. This is an abstract type hierarchy derived from:","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"abstract type ProtocolEvent end","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"MPIMeasurements.jl already provides a number of Event types. Most are designed as query/answer pairs. The follow examples hightlight a few pairs.","category":"page"},{"location":"framework/protocols.html#Event-Examples","page":"Protocols","title":"Event Examples","text":"","category":"section"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"When a Protocol is running, it is helpful to know how far it progressed, especially for longer running Protocol. For this, the ProgressEvents exist. With these a caller can query the Protocol how far it is done and can receives an Event containing an X/Y reply. ","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"struct ProgressQueryEvent <: ProtocolEvent end\nstruct ProgressEvent <: ProtocolEvent\n  done::Int\n  total::Int\n  unit::AbstractString\n  query::ProgressQueryEvent\nend","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"If a Protocol requires input from the user, it has multiple options. If the input is a yes/no question one can use the following:","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"struct DecisionEvent <: ProtocolEvent\n  message::AbstractString\nend\nstruct AnswerEvent <: ProtocolEvent\n  answer::Bool\n  question::DecisionEvent\nend","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"This requires a caller that is able to reply to Protocol queries. Protocols that potentially ask for user input possess the Interactive trait.","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"A last important Event example concerns the end of a Protocol. It is recommended that a Protocols Task does not simply end, instead it should notify the caller that it finished. This allows the caller to query for relevant measurement data or request the Protocol to save the data to a file. This process is covered by the following Events:","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"struct FinishedNotificationEvent <: ProtocolEvent end\nstruct FinishedAckEvent <: ProtocolEvent end","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"Only after receiving an acknowledgement should the protocol finish.","category":"page"},{"location":"framework/protocols.html#Event-Handling","page":"Protocols","title":"Event Handling","text":"","category":"section"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"A common way for Protocols to interact with events is the following pattern:","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"function measurementStep(protocol::ExampleProtocol)\n  step = @tspawnat protocol.scanner.runtime.producerThreadID doStep(protocol)\n  while !istaskdone(step)\n    handleEvents(protocol)\n    sleep(0.05)\n  end\nend","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"Here, the Protocol does not block its own execution task with a measurement step, instead it spawns a dedicated Task on a different thread. This leaves the Protocol free to react to Events. It invokes the provided function handleEvents:","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"function handleEvents(protocol::Protocol)\n  while isready(protocol.biChannel)\n    event = take!(protocol.biChannel)\n    handleEvent(protocol, event)\n  end\nend","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"With this function, a Protocol only has to write a function like the following to react to an Event:","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"function handleEvent(protocol::MPIMeasurementProtocol, event::ProgressQueryEvent)\n  framesTotal = protocol..numFrames\n  framesDone = min(protocol..nextFrame - 1, framesTotal)\n  reply = ProgressEvent(framesDone, framesTotal, \"Frames\", event)\n  put!(protocol.biChannel, reply)\nend","category":"page"},{"location":"framework/protocols.html#Implementing-New-Protocols","page":"Protocols","title":"Implementing New Protocols","text":"","category":"section"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"The following example implements a Protocol, that uses moves a Robot to several defined positions and measures the temperature using a TemperatureSensor like the one implemented in the Device example.","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"MPIMeasurements.jl already provides a family of robot-based Protocols, which can be found here. In particular, this already provides an implementation of the _execute function, which is further annotated with comments for this example:","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"function _execute(protocol::RobotBasedProtocol)\n  @info \"Start $(typeof(protocol))\"\n  scanner_ = scanner(protocol)\n  robot = getRobot(scanner_)\n  if !isReferenced(robot)\n    # Any exception thrown in _execute, produces an ExceptionEvent\n    throw(IllegalStateException(\"Robot not referenced! Cannot proceed!\"))\n  end\n\n  initMeasData(protocol) # This is method needs to be implemented\n\n  finished = false\n  notifiedStop = false\n  while !finished\n    finished = performMovements(protocol)\n\n    # This code block handels pausing and resuming the measurement \n    notifiedStop = false\n    # protocol.stopped is set when a StopEvent is received\n    while protocol.stopped\n      handleEvents(protocol) # Here we react to Events again\n      protocol.cancelled && throw(CancelException())\n      if !notifiedStop\n        # Notify once that we paused\n        put!(protocol.biChannel, OperationSuccessfulEvent(StopEvent()))\n        notifiedStop = true\n      end\n      if !protocol.stopped\n        # Notify that we resumed\n        put!(protocol.biChannel, OperationSuccessfulEvent(ResumeEvent()))\n      end\n      sleep(0.05)\n    end\n  end\n\n  # Notify the caller that the protocol finished\n  put!(protocol.biChannel, FinishedNotificationEvent())\n  # Await acknowledgement\n  while !protocol.finishAcknowledged\n    handleEvents(protocol)\n    protocol.cancelled && throw(CancelException())\n    sleep(0.01)\n  end\n  @info \"Protocol finished.\"\nend","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"The function uses several internal fields, such as stopped, cancelled and  finishedAcknowledged which are mandatory for robot-based Protocols, additionally to the ones mandatory for any Protocol.","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"The robot-based Protocols are implement as a multi-threaded process with three distinct steps per robot movement. A Protocol can performan an action before, during and after a movement:","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"function performMovement(protocol::RobotBasedProtocol, robot::Robot, pos::ScannerCoords)\n  @info \"Pre movement\"\n  preMovement(protocol) # Needs to be implemented\n\n  enable(robot)\n  try\n    @sync begin \n      @info \"During movement\"\n      moveRobot = @tspawnat protocol.scanner.runtime.serialThreadID moveAbs(robot, pos)\n      duringMovement(protocol, moveRobot) # Needs to be implemented\n    end\n  catch ex \n    if ex isa CompositeException\n      @error \"CompositeException while preparing measurement:\"\n      for e in ex\n        @error e\n      end\n    end\n    rethrow(ex)\n  end\n  disable(robot)\n  \n  @info \"Post movement\"\n  postMovement(protocol) # Needs to be implemented\nend","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"The performMovement function has as an argument the next position to drive to. This argument is provided by the nextPosition function, which our Protocol also needs to implement.","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"With this overview of what needs to be implemented one can start writing the Protocol. We define the following parameters type: ","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"Base.@kwdef mutable struct RobotBasedTempMeasProtocolParams <: RobotBasedProtocolParams\n  positions::GridPositions\nend\nRobotBasedTempMeasProtocolParams(dict::Dict, scanner::MPIScanner) = RobotBasedTempMeasProtocolParams(positions = Positions(dict[\"Positions\"]))","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"Note that while we directly set the keyword argument here, it is also possible to use params_from_dict like we did in for the Device example. Next we define the Protocol itself:","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"Base.@kwdef mutable struct RobotBasedTempMeasProtocol <: RobotBasedProtocol\n  # Protocol mandatory fields\n  @add_protocol_fields RobotBasedTempMeasProtocolParams\n  # Measurement data\n  data::Union{Nothing, Matrix{Float64}} = nothing\n  # Position data\n  positions::Union{Nothing, GridPositions} = nothing\n  currPos::Int64 = 0\n  # Robot based protocol mandatory fields\n  stopped::Bool = false\n  cancelled::Bool = false\n  finishAcknowledged::Bool = false\nend","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"The struct definition contains the mentioned additonal mandatory fields, as well as fields to track the current position and lastly the measurement data itself.","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"The next functions finish all necessary implementations up to the execute phase of a Protocol.","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"requiredDevices(RobotBasedTempMeasProtocol) = [Robot, TemperatureSensor]\nfunction _init(protocol::RobotBasedTempMeasProtocol)\n  protocol.positions = copy(protocol.params.positions)\n  sensor = getDevice(protocol.scanner, TemperatureSensor)\n  protocol.data = zeros(Float64, numChannels(sensor), length(protocol.positions))\nend\nfunction enterExecute(protocol::RobotBasedTempMeasProtocol)\n  protocol.stopped = false\n  protocol.cancelled = false\n  protocol.finishAcknowledged = false\n  protocol.currPos = 1\nend","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"Next up is the initMeasData function. As robot-based Protocol can be very time-intensive, they often times features persistent storage of measurement data to allow a user to resume a measurement should an error occur. This case could be handled here, as during the execution phase a Protocol can query the user. In our case the function is just empty, which is already the default provided implementation. Likewise, our Protocol does not need to do anything before a robot movement. ","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"To be able to move the robot, our Protocol needs to supply positions with the following function:","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"function nextPosition(protocol::RobotBasedTempMeasProtocol)\n  if protocol.currPos <= length(protocol.positions)\n    return ScannerCoords(uconvert.(Unitful.mm, protocol.positions[protocol.currPos]))\n  end\n  return nothing\nend","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"Then during a robot movement we can react to user Events, such as ProgressQueryEvents:","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"function duringMovement(protocol::RobotBasedTempMeasProtocol, moving::Task)\n  while !istaskdone(moving)\n    handleEvents(protocol)\n    sleep(0.05)\n  end\nend\nfunction handleEvent(protocol::RobotBasedTempMeasProtocol, event::ProgressQueryEvent)\n  reply = ProgressEvent(protocol.currPos, length(protocol.positions), \"Position\", event)\n  put!(protocol.biChannel, reply)\nend","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"After a robot movement a measurement can be performed:","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"function postMovement(protocol::RobotBasedTempMeasProtocol)\n  # Perform measurement\n  sensor = getDevice(protocol.scanner, TemperatureSensor)\n  producer = @tspawnat protocol.scanner.runtime.producerThreadID begin\n    data = getTemperatures(sensor)\n    protocol.data[:, protocol.currPos] = data\n  end\n\n  # Wait\n  while !istaskdone(producer)\n    handleEvents(protocol)\n    sleep(0.05)\n  end\n\n  protocol.currPos += 1\nend","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"Lastly a user should be able to retrieve or store the measurement data. Proper MPI measurements can be stored in MDF, however in our case we can also simply reply to DataQuery- and simple FileStorageRequestEvents:","category":"page"},{"location":"framework/protocols.html","page":"Protocols","title":"Protocols","text":"function handleEvent(protocol::RobotBasedTempMeasProtocol, event::FileStorageRequestEvent)\n  filename = event.filename\n  open(filename, \"w\") do file\n    writedlm(file, protocol.data) # from DelimitedFiles.jl, writes a CSV\n  end\n  put!(protocol.biChannel, StorageSuccessEvent(filename))\nend\n\nfunction handleEvent(protocol::RobotBasedTempMeasProtocol, event::DataQueryEvent)\n  msg = event.message\n  reply = nothing\n  if msg = \"DATA\"\n    reply = protocol.data\n  else\n   # ...\n  end\n  put!(protocol.biChannel, DataAnswerEvent(reply, event))\nend","category":"page"},{"location":"framework/scanner.html#Scanner","page":"Scanner","title":"Scanner","text":"","category":"section"},{"location":"framework/scanner.html","page":"Scanner","title":"Scanner","text":"A Scanner represents a composition of hard- and software components or Devices and a set of configuration files. Each scanner is defined in its own configuration directory with the following structure:","category":"page"},{"location":"framework/scanner.html","page":"Scanner","title":"Scanner","text":"ScannerName/\n├── Sequences/\n│   └── <sequence 1 name>.toml\n│   └── <sequence 2 name>.toml\n│   └── ...\n├── Devices/\n│   └── <device 1 name>.toml\n│   └── <device 2 name>.toml\n│   └── ...\n├── Protocols/\n│   └── <protocol 1 name>.toml\n│   └── <protocol 2 name>.toml\n│   └── ...\n└── Scanner.toml","category":"page"},{"location":"framework/scanner.html","page":"Scanner","title":"Scanner","text":"The Scanner data structure is the entry point for working with an MPI system within MPIMeasurements.jl, as it manages both the composition of Devices and the construction of Sequences and Protocols based on the configuration directory. A Scanner is constructed with the MPIScanner function and the name of the desired configuration directoy:  ","category":"page"},{"location":"framework/scanner.html","page":"Scanner","title":"Scanner","text":"julia> scanner = MPIScanner(\"ScannerName\");","category":"page"},{"location":"framework/scanner.html","page":"Scanner","title":"Scanner","text":"During construction, all Devices of the scanner are also constructed and initialised according to the parameters contained in the Scanner.toml configuration file.","category":"page"},{"location":"framework/scanner.html#Scanner.toml","page":"Scanner","title":"Scanner.toml","text":"","category":"section"},{"location":"framework/scanner.html","page":"Scanner","title":"Scanner","text":"The Scanner.toml contains the configuration parameters of the Scanner and is structured into three sections. ","category":"page"},{"location":"framework/scanner.html#General-Section","page":"Scanner","title":"General Section","text":"","category":"section"},{"location":"framework/scanner.html","page":"Scanner","title":"Scanner","text":"The general section contains the details of the scanner. The fields correspond to the scanner group of the MPI data format (MDF) and are used when writing a measurement to disk. All fields that have units will be parsed with Unitful and should therefore be denoted as strings with the unit attached without a space. This also applies to the Device Section.","category":"page"},{"location":"framework/scanner.html","page":"Scanner","title":"Scanner","text":"[General]\nboreSize = \"XXmm\"\nfacility = \"<facility>\"\nmanufacturer = \"<manufacturer>\"\nname = \"<scanner name>\"\ntopology = \"<FFP|FFL|MPS>\"\ngradient = \"XXT/m\"","category":"page"},{"location":"framework/scanner.html","page":"Scanner","title":"Scanner","text":"In addition, the General section contains hints for Protocol, scripts and GUI implementations, such as on which Julia threads to run certain threads or which default Sequences to display.","category":"page"},{"location":"framework/scanner.html","page":"Scanner","title":"Scanner","text":"defaultProtocol = \"<protocol X name>\"\ndatasetStore = \"<file path\">\n# Which Julia threads to run common tasks on\nproducerThreadID = 1\nprotocolThreadID = 2\n\nconsumerThreadID = 3\nserialThreadID = 4","category":"page"},{"location":"framework/scanner.html#Device-Section","page":"Scanner","title":"Device Section","text":"","category":"section"},{"location":"framework/scanner.html","page":"Scanner","title":"Scanner","text":"All devices that can be used by the scanner should be listed in this section. It describes the hardware properties such as maximum and minimum values for DAQ devices, connection details such as IPs, etc. Aside from common parameters such as the deviceType or the dependencies, the parameters of each device type can differ.","category":"page"},{"location":"framework/scanner.html","page":"Scanner","title":"Scanner","text":"Since the initialization order sometimes matters, it must be explicitly specified in the main section by putting the device IDs in the correct order. Each device must specify at least one deviceType corresponding to the respective device structure.","category":"page"},{"location":"framework/scanner.html","page":"Scanner","title":"Scanner","text":"[Devices]\ninitializationOrder = [\n    \"my_device_id1\",\n    \"my_device_id2\"\n]\n\n[Devices.my_device_id1]\ndeviceType = \"<device type as given by the struct name>\"\nparameter1 = 1000\nparameter2 = \"25kHz\"\n\n[Devices.my_device_id2]\ndeviceType = \"<device type as given by the struct name>\"\ndependencies = [\"my_device_id1\"]\nparameter = \"192.168.1.100\"","category":"page"},{"location":"framework/devices.html#Devices","page":"Devices","title":"Devices","text":"","category":"section"},{"location":"framework/devices.html","page":"Devices","title":"Devices","text":"A Device is a configurable and stateful (interface to) a hard- or software component, such as the interface to a robot or a software component that controls the phase and amplitude of a drive field.","category":"page"},{"location":"framework/devices.html","page":"Devices","title":"Devices","text":"The Device types form a type hierarchy with the root type ","category":"page"},{"location":"framework/devices.html","page":"Devices","title":"Devices","text":"abstract type Device end","category":"page"},{"location":"framework/devices.html","page":"Devices","title":"Devices","text":"and feature generic interfaces and implementations. However, due to the nature of Julias multiple-dispatch, each Device can specialize and fully express its features at the cost of potentially diverging from its generic interface.","category":"page"},{"location":"framework/devices.html","page":"Devices","title":"Devices","text":"During Scanner construction, all its Devices listed in the initialization order parameter are also initialized. During the Device initialization, the Device can access its own parameters as given in the configuration file and all the Devices it depends on.","category":"page"},{"location":"framework/devices.html#Structure","page":"Devices","title":"Structure","text":"","category":"section"},{"location":"framework/devices.html","page":"Devices","title":"Devices","text":"Each concrete Device implementation is a mutable composite type in the Device type hierarchy. ","category":"page"},{"location":"framework/devices.html","page":"Devices","title":"Devices","text":"The fields of each Device can be grouped into three parts. ","category":"page"},{"location":"framework/devices.html#Common-Device-Fields","page":"Devices","title":"Common Device Fields","text":"","category":"section"},{"location":"framework/devices.html","page":"Devices","title":"Devices","text":"Every Device must have the fields deviceID, params, present and dependencies, as these are the fields used during automatic instantiation of a Scanner.","category":"page"},{"location":"framework/devices.html","page":"Devices","title":"Devices","text":"The deviceID is the name of a specific Device instance and corresponds to the name/key used in the Scanner.toml. The params field contains the user provided configuration parameters (see Device Parameter Field). ","category":"page"},{"location":"framework/devices.html","page":"Devices","title":"Devices","text":"Lastly the present field denotes if a Device was succesfully initialized and the dependencies field contains a Dict containing all the dependent Devices of the current Device. ","category":"page"},{"location":"framework/devices.html#Device-Parameter-Field","page":"Devices","title":"Device Parameter Field","text":"","category":"section"},{"location":"framework/devices.html","page":"Devices","title":"Devices","text":"Every Device must implement a type for the configuration parameters used during automatic instantiation. ","category":"page"},{"location":"framework/devices.html","page":"Devices","title":"Devices","text":"These parameter types must inherit from the DeviceParams type and must be named like the Device type they belong to with the added suffix of Params:","category":"page"},{"location":"framework/devices.html","page":"Devices","title":"Devices","text":"mutable struct Example <: Device\n    ...\nend\nstruct ExampleParams <: DeviceParams\n    parameter1::String\n    parameter2::Int64\nend","category":"page"},{"location":"framework/devices.html","page":"Devices","title":"Devices","text":"It is also possible to offer several variants of configuration parameters by providing a type hierarchy with an abstract root type <DeviceType>Params.","category":"page"},{"location":"framework/devices.html#Internal-Device-Fields","page":"Devices","title":"Internal Device Fields","text":"","category":"section"},{"location":"framework/devices.html","page":"Devices","title":"Devices","text":"And finally a Device can contain any number of \"internal\" fields, these are intended to be used to handle resources, such as connections, or any number of internal states. These fields need to be provided with a default value.","category":"page"},{"location":"framework/devices.html#Initialization","page":"Devices","title":"Initialization","text":"","category":"section"},{"location":"framework/devices.html","page":"Devices","title":"Devices","text":"Automatic initialization of a Device happens in two phases. First, the key/value pairs of the Scanner.toml for a given Device are passed to all potential DeviceParams as a constructor. If a fitting paramter type was found, the corresponding Device type is constructed with the parameter type set.","category":"page"},{"location":"framework/devices.html","page":"Devices","title":"Devices","text":"Afterwards, the _init function of the constructed Device is called, which executes user-defined code that should check the provied paramteres and prepare internal device fields. During this second process, a Device can access all the Devices it depends on.","category":"page"},{"location":"framework/devices.html#Functions","page":"Devices","title":"Functions","text":"","category":"section"},{"location":"framework/devices.html","page":"Devices","title":"Devices","text":"Todo","category":"page"},{"location":"framework/devices.html#Implementing-New-Devices","page":"Devices","title":"Implementing New Devices","text":"","category":"section"},{"location":"framework/devices.html","page":"Devices","title":"Devices","text":"The following example shows how to implement a new Device. The chosen device is an interface to a temperature sensor, that can be queried via TCP/IP to return new temperature values. The made up sensor only has one channel/value.","category":"page"},{"location":"framework/devices.html","page":"Devices","title":"Devices","text":"To \"simplify\" configuration and showcase the DeviceParams, a user can either directly specify an IP or provided a number of IPs which the Device sequentially checks in the Scanner.toml.","category":"page"},{"location":"framework/devices.html","page":"Devices","title":"Devices","text":"Checking the existing Device tree shows that there are already a number of temperature sensor implementation and in particular, there is an abstract TemperatureSensor type. Therefore, the new Device should inherit from this type. Furthermore, the abstract type also defines a number of functions, which need to be implemented for the new sensor.","category":"page"},{"location":"framework/devices.html","page":"Devices","title":"Devices","text":"This gives the following starting point, which will evolve throughout the example:","category":"page"},{"location":"framework/devices.html","page":"Devices","title":"Devices","text":"mutable struct IPTempSensor <: TemperatureSensor\n    ...\nend\nabstract type IPTempSensorParams <: DeviceParams end\nstruct IPTempSensorDirectParams <: IPTempSensorParams\n    ip::String\n    channelName::String\nend\nstruct IPTempSensorSequentialParams <: IPTempSensorParams\n    ips::Vector{String} # Note ip != ips, the names need to differ\n    channelName::String\nend","category":"page"},{"location":"framework/devices.html","page":"Devices","title":"Devices","text":"The start already shows the type hierarchy for two types of parameters. It is only important that the abstract type follows the rule of device name and params suffix.","category":"page"},{"location":"framework/devices.html","page":"Devices","title":"Devices","text":"Next one needs to implement the Params constructor, which takes a Dict as input. Here, MPIMeasurements.jl and Julia offers a few convience options. First, one can use the Base.@kwdef macro. This macro automatically defines keyword based constructors for a structure and it allows the definition of default values:","category":"page"},{"location":"framework/devices.html","page":"Devices","title":"Devices","text":"Base.@kwdef struct IPTempSensorDirectParams <: IPTempSensorParams\n    ip::String\n    channelName::String = \"N/A\"\nend","category":"page"},{"location":"framework/devices.html","page":"Devices","title":"Devices","text":"This allows the structure to be constructed like this:","category":"page"},{"location":"framework/devices.html","page":"Devices","title":"Devices","text":"julia> params = IPTempSensorDirectParams(ip=\"192.168.1.100\")","category":"page"},{"location":"framework/devices.html","page":"Devices","title":"Devices","text":"However, this is still not enough to simply construct a parameter object from the Dict, as the Dict contains a mapping of String to values. For the constructor, one needs a mapping of Symbols to values. Symbols in Julia are interned Strings. This conversion is something provided by MPIMeasurements.jl with the params_from_dict function:","category":"page"},{"location":"framework/devices.html","page":"Devices","title":"Devices","text":"Base.@kwdef struct IPTempSensorDirectParams <: IPTempSensorParams\n    ip::String\n    channelName::String = \"N/A\"\nend\nIPTempSensorDirectParams(dict::Dict) = params_from_dict(IPTempSensorDirectParams, dict)","category":"page"},{"location":"framework/devices.html","page":"Devices","title":"Devices","text":"The other parameter type requires the same changes. Now with the macro and provided function, the constructor for the parameter types is finished. In the Scanner.toml a user can now write something like:","category":"page"},{"location":"framework/devices.html","page":"Devices","title":"Devices","text":"[Devices.ipSensor]\ndeviceType = \"IPTempSensor\"\nip = \"192.168.1.100\"\nchannelName = \"Drive Field Temp\"","category":"page"},{"location":"framework/devices.html","page":"Devices","title":"Devices","text":"and MPIMeasurements.jl would find the IPTempSensorDirectParams in the first phase of Device construction.","category":"page"},{"location":"framework/devices.html","page":"Devices","title":"Devices","text":"Now the parameter type must be added to the Device type itself, together with all other mandatory fields. Here, MPIMeasurements.jl provides another macro, which given a parameter type name, adds all the mandatory fields to a struct:","category":"page"},{"location":"framework/devices.html","page":"Devices","title":"Devices","text":"Base.@kwdef mutable struct IPTempSensor <: TemperatureSensor\n    @add_device_fields IPTempSensorParams\n    conn::Union{Nothing, TCPSocket} = nothing\nend","category":"page"},{"location":"framework/devices.html","page":"Devices","title":"Devices","text":"The structure was also provided with a keyword constructor and an added internal field to hold the necessary TCP connection. As this is an internal field, it needed to be provided with a default value. ","category":"page"},{"location":"framework/devices.html","page":"Devices","title":"Devices","text":"The final step for automatic initialization is implementing the mandatory Device functions. The sensor itself does not have any required dependencies, which means those can be left empty:","category":"page"},{"location":"framework/devices.html","page":"Devices","title":"Devices","text":"neededDependencies(::IPTempSensor) = []\noptionalDependencies(::IPTempSensor) = []","category":"page"},{"location":"framework/devices.html","page":"Devices","title":"Devices","text":"This only leaves the _init function, during which the parameters need to be checked and the TCP connection established. However, the Device has two different types of parameters. This can be handled with Julias multiple-dispatch:","category":"page"},{"location":"framework/devices.html","page":"Devices","title":"Devices","text":"function _init(sensor::IPTempSensor) \n    sensor.conn = establishConnection(sensor, sensor.params)\n    if isnothing(sensor.conn)\n        throw(ScannerConfigurationError(\"Could not connect to sensor\"))\n    end\nend\n\nfunction establishConnection(sensor::IPTempSensor, params::IPTempSensorDirectParams)\n    conn = connect(params.ip)\n    if # Test if connected to correct device \n        return conn\n    else\n        return nothing\n    end\nend\n\nfunction establishConnection(sensor::IPTempSensor, params::IPTempSensorSequentialParams)\n    for ip in params.ips\n        conn = connect(params.ip)\n        # Return if valid connection\n    end\n    return nothing\nend","category":"page"},{"location":"framework/devices.html","page":"Devices","title":"Devices","text":"Now the sensor can be automatically initialized by MPIMeasurements.jl. In order to be used as a temperature sensor, however, the sensor-specific functions are still missing. As a last example, here are three of missing implemented functions:","category":"page"},{"location":"framework/devices.html","page":"Devices","title":"Devices","text":"numChannels(sensor::IPTempSensor) = 1\ngetChannelNames(sensor::IPTempSensor) = [sensor.params.channelName]\nfunction getTemperature(sensor::IPTempSensor, channel::Int)\n    if channel != 1\n        throw(ArgumentError(\"IPTempSensor only has one channel, can not access channel $channel\"))\n    end\n    write(sensor.conn, \"TEMP?\")\n    reply = readline(sensor.conn)\n    return parse(reply, Float64)\nend","category":"page"},{"location":"framework/devices.html","page":"Devices","title":"Devices","text":"Once these are implemented, every Protocol, script and GUI that works with the other temperature sensors will seamlessly work with the new one. But it is also possible to specialise specific parts of Protocol to have unique behaviour for this particular sensor using multiple-dispatch.","category":"page"},{"location":"lib/framework/device.html#MPIMeasurements.deviceID","page":"Device","title":"MPIMeasurements.deviceID","text":"Retrieve the ID of a device.\n\n\n\n\n\n","category":"function"},{"location":"lib/framework/device.html#MPIMeasurements.params","page":"Device","title":"MPIMeasurements.params","text":"Retrieve the parameters of a device.\n\n\n\n\n\n","category":"function"},{"location":"lib/framework/device.html#MPIMeasurements.isOptional","page":"Device","title":"MPIMeasurements.isOptional","text":"Check whether the device is optional.\n\n\n\n\n\n","category":"function"},{"location":"lib/framework/device.html#MPIMeasurements.isPresent","page":"Device","title":"MPIMeasurements.isPresent","text":"Check whether the device is present.\n\n\n\n\n\n","category":"function"},{"location":"lib/framework/device.html#MPIMeasurements.dependencies-Tuple{Device}","page":"Device","title":"MPIMeasurements.dependencies","text":"Retrieve the dependencies of a device.\n\n\n\n\n\n","category":"method"},{"location":"lib/framework/device.html#MPIMeasurements.dependencies-Tuple{Device, DataType}","page":"Device","title":"MPIMeasurements.dependencies","text":"Retrieve all dependencies of a certain type.\n\n\n\n\n\n","category":"method"},{"location":"lib/framework/device.html#MPIMeasurements.dependency-Tuple{Device, DataType}","page":"Device","title":"MPIMeasurements.dependency","text":"Retrieve a single dependency of a certain type and error if there are more dependencies.\n\n\n\n\n\n","category":"method"},{"location":"lib/framework/device.html#MPIMeasurements.dependency-Tuple{Device, String}","page":"Device","title":"MPIMeasurements.dependency","text":"Retrieve a single dependency with a certain device ID.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/internals.html#Some-internal-stuff","page":"Some internal stuff","title":"Some internal stuff","text":"","category":"section"},{"location":"config/devices.html#Device-Parameters","page":"Devices","title":"Device Parameters","text":"","category":"section"},{"location":"config/devices.html#DAQ","page":"Devices","title":"DAQ","text":"","category":"section"},{"location":"config/devices.html#MPIMeasurements.RedPitayaDAQParams","page":"Devices","title":"MPIMeasurements.RedPitayaDAQParams","text":"Parameters for a DAQ of type RedPitayaDAQ\n\nchannels: All configured channels of this DAQ device.\nips: IPs of the Red Pitayas\ntriggerMode: Trigger mode of the Red Pitayas. Default: ALL_INTERNAL.\nresetWaittime: Time to wait after a reset has been issued.\nrampingMode\nrampingFraction\nuseCounterTrigger: Flag for using the counter trigger\ncounterTriggerSourceType: Source type of the counter trigger\ncounterTriggerSourceChannel: DIO pin used for the counter trigger\n\n\n\n\n\n","category":"type"},{"location":"config/devices.html#MPIMeasurements.RedPitayaLUTChannelParams","page":"Devices","title":"MPIMeasurements.RedPitayaLUTChannelParams","text":"Parameters for a TxChannel of type RedPitayaLUTChannel\n\nchannelIdx\ncalibration\nrange\nhbridge\nswitchTime\nswitchEnable\n\n\n\n\n\n","category":"type"},{"location":"config/devices.html#MPIMeasurements.DAQRxChannelParams","page":"Devices","title":"MPIMeasurements.DAQRxChannelParams","text":"Parameters for a general DAQRxChannel\n\nchannelIdx: required, Integer, channel idx of the corresponding DAQ\ntransferFunction: optional, can be either a filename to a .h5 file in the TransferFunctions folder or a single (complex) number\n\n\n\n\n\n","category":"type"},{"location":"config/devices.html#MPIMeasurements.DAQTxChannelParams","page":"Devices","title":"MPIMeasurements.DAQTxChannelParams","text":"Parameters for a general DAQTxChannel\n\nchannelIdx\nlimitPeak\nlimitSlewRate\nsinkImpedance\nallowedWaveforms\nfeedbackChannelID\ncalibration\n\n\n\n\n\n","category":"type"},{"location":"config/devices.html#TxController","page":"Devices","title":"TxController","text":"","category":"section"},{"location":"config/devices.html#MPIMeasurements.TxDAQControllerParams","page":"Devices","title":"MPIMeasurements.TxDAQControllerParams","text":"Parameters for a TxDAQController`\n\nphaseAccuracy: Angle, required, allowed deviation of the excitation phase\nrelativeAmplitudeAccuracy: Number, required, allowed relative deviation of the excitation amplitude\nabsoluteAmplitudeAccuracy: Magnetic field, default: 50µT, allowed absolute deviation of the excitation amplitude\nmaxControlSteps: Integer, default: 20, maximum number of steps to try to control the system\ncontrolDC: Bool, default: false, control the DC value of the excitation field (only posible for DC enabled DF amplifiers)\ntimeUntilStable: Float, default: 0.0, time in seconds to wait before the DF is stable after ramping\nminimumStepDuration: Float, default: 0.002, time in seconds that the DF should be averaged during the control measurement\nfieldToVoltRelDeviation: Float, default: 0.2, relative deviation allowed between forward calibration and actual system state\nfieldToVoltAbsDeviation: Magnetic field, default: 5.0mT, absolute deviation allowed between forward calibration and actual system state\nmaxField: Magnetic field, default: 40mT, maximum field amplitude that the controller should allow\n\n\n\n\n\n","category":"type"},{"location":"config/scanner.html#Scanner-Parameters","page":"Scanner","title":"Scanner Parameters","text":"","category":"section"},{"location":"config/scanner.html#MPIMeasurements.MPIScannerGeneral","page":"Scanner","title":"MPIMeasurements.MPIScannerGeneral","text":"General description of the scanner.\n\nNote: The fields correspond to the root section of an MDF file.\n\nboreSize: Bore size of the scanner.\nfacility: Facility where the scanner is located.\nmanufacturer: Manufacturer of the scanner.\nname: Name of the scanner\ntopology: Topology of the scanner, e.g. FFL or FFP.\ngradient: Gradient of the scanners selection field.\ndatasetStore: Path of the dataset store.\ndefaultProtocol: Default protocol of the scanner.\nproducerThreadID: Thread ID of the producer thread.\nconsumerThreadID: Thread ID of the consumer thread.\nprotocolThreadID: Thread ID of the producer thread.\nserialThreadID: Thread ID of the dedicated serial port thread\n\n\n\n\n\n","category":"type"},{"location":"lib/base/devices/robots/interface.html#Robots","page":"Interface","title":"Robots","text":"","category":"section"},{"location":"lib/base/devices/robots/interface.html#Interface","page":"Interface","title":"Interface","text":"","category":"section"},{"location":"lib/base/devices/robots/interface.html#Must-Implement","page":"Interface","title":"Must Implement","text":"","category":"section"},{"location":"index.html#MPIMeasurements.jl","page":"Home","title":"MPIMeasurements.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"A measurement and instrumentation framework for magnetic particle imaging (MPI) and magnetic particle spectroscopy systems.","category":"page"},{"location":"index.html#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This package provides tools for acquiring MPI data by providing a composable representation for working with the scanner hardware. With the use of simple configuration files you can describe your hardware and run specific imaging protocols on it. The project is designed to be expanded to new systems through community development and component reuse.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The main components of the project are:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Scanner, a composition of devices representing the hardware\nDevices, generic interfaces and implementations to/of hard- and software components of a scanner\nSequences, abstract representation of magnetic fields and acquisition parameters\nProtocols, complex measurements procedures, that can be executed in scripts, GUIs or the Julia REPL","category":"page"},{"location":"index.html#License-/-Terms-of-Usage","page":"Home","title":"License / Terms of Usage","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"The source code of this project is licensed under the MIT license. This implies that you are free to use, share, and adapt it. However, please give appropriate credit by citing the project.","category":"page"},{"location":"index.html#Community-Guidelines","page":"Home","title":"Community Guidelines","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"If you have problems using the software, find bugs, or have feature requests please use the issue tracker to contact us. For general questions we prefer that you contact the current maintainers directly by email.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"We welcome community contributions to MPIMeasurements.jl. Simply create a pull request with your proposed changes.","category":"page"},{"location":"index.html#Maintainer","page":"Home","title":"Maintainer","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Tobias Knopp\nNiklas Hackelberg\nJonas Schumacher","category":"page"}]
}
